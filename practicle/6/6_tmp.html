<!DOCTYPE html>
<html>
<head>
<title>6.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="expeiment-5">Expeiment 5</h1>
<h2 id="aim">Aim</h2>
<p>Study of Network Simulator (NS)</p>
<h2 id="theory">Theory</h2>
<p>Network Simulator (Version 2), widely known as NS2, is simply an event driven simulation tool that has proved useful in studying the dynamic nature of communication networks. Simulation of wired as well as wireless network functions and protocols (e.g., routing algorithms, TCP, UDP) can be done using NS2. In general, NS2 provides users with a way of specifying such network protocols and simulating their corresponding behaviors. Due to its flexibility and modular nature, NS2 has gained constant popularity in the networking research community since its birth in 1989.</p>
<h2 id="basic-architecture">Basic Architecture</h2>
<p>NS2 consists of two key languages: C++ and Object-oriented Tool Command Language (OTcl). While the C++ defines the internal mechanism (i.e., a backend) of the simulation objects, the OTcl sets up simulation by assembling and configuring the objects as well as scheduling discrete events. The C++ and the OTcl are linked together using TclCL</p>
<p><img src="https://www.tutorialsweb.com/ns2/NS2-1.1.jpg" alt="NS2 Architecture"></p>
<h2 id="tcl">TCL</h2>
<p>Tcl (pronounced &quot;tickle&quot; or as an initialism) is a high-level, general-purpose, interpreted, dynamic programming language. It was designed with the goal of being very simple but powerful. Tcl casts everything into the mold of a command, even programming constructs like variable assignment and procedure definition.</p>
<h3 id="basic-syntax">Basic Syntax</h3>
<p>Tcl commands are composed of words separated by white space. The first word is the name of the command and the remaining words are arguments to the command. The following example shows how to use the puts command to print a string:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">puts</span> <span class="hljs-string">"Hello World"</span>
</div></code></pre>
<h3 id="comments">Comments</h3>
<p>Tcl supports two types of comments: single line comments and multi-line comments. Single line comments start with a hash sign (#) and end with a newline character. Multi-line comments start with the string /<em>and end with the string</em>/. The following example shows how to use comments:</p>
<pre class="hljs"><code><div><span class="hljs-comment"># This is a single line comment</span>
<span class="hljs-keyword">puts</span> <span class="hljs-string">"Hello World"</span> # This is a single line comment
<span class="hljs-keyword">puts</span> <span class="hljs-string">"Hello World"</span> /* This is a multi-line comment */ <span class="hljs-keyword">puts</span> <span class="hljs-string">"Hello World"</span>
</div></code></pre>
<h3 id="variables">Variables</h3>
<p>Variables are used to store values. The value of a variable is substituted by its name preceded by a dollar sign. The value of a variable is set using the set command. The set command takes two arguments: the name of the variable and the value to be stored in the variable. The value of a variable can be retrieved using the set command with only one argument: the name of the variable. The following example shows how to use variables:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">set</span> a <span class="hljs-number">10</span>
<span class="hljs-keyword">set</span> b <span class="hljs-number">20</span>
</div></code></pre>
<h3 id="control-structures">Control Structures</h3>
<p>Tcl has the usual control structures such as if, while, for, and switch. The if command takes a condition and a body of code to execute if the condition is true. The condition is an expression that evaluates to a boolean value. The body of code is a Tcl script enclosed in braces. The following example shows how to use the if command:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> {$a &lt; $b} {
    <span class="hljs-keyword">puts</span> <span class="hljs-string">"$a is less than $b"</span>
} else {
    <span class="hljs-keyword">puts</span> <span class="hljs-string">"$a is greater than or equal to $b"</span>
}
</div></code></pre>
<h2 id="initialization-and-termination-of-tcl-script-in-ns-2">Initialization and Termination of TCL Script in NS-2</h2>
<p>To initialize an NS simulation, the first line in the TCL script should declare a new variable using the <code>set</code> command as follows:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">set</span> ns [new Simulator]
</div></code></pre>
<p>The variable <code>ns</code> represents an instance of the <code>Simulator</code> class, which is created using the reserved word <code>new</code>. To create output files for simulation trace data and visualization, use the <code>open</code> command as follows:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">set</span> tracefile1 [<span class="hljs-keyword">open</span> out.tr w]
$ns <span class="hljs-keyword">trace</span>-all $tracefile1
<span class="hljs-keyword">set</span> namfile [<span class="hljs-keyword">open</span> out.nam w]
$ns namtrace-all $namfile
</div></code></pre>
<p>These commands create a data trace file called <code>out.tr</code> and a visualization trace file called <code>out.nam</code>. The files are not called explicitly by name within the TCL script, but by pointers declared above as <code>tracefile1</code> and <code>namfile</code>, respectively. Note that these pointers begin with the <code>#</code> symbol. The <code>trace-all</code> method is used to record all simulation traces in the <code>out.tr</code> file, and the <code>namtrace-all</code> method is used to record the visualization trace in the <code>out.nam</code> file. To terminate the program, use the <code>finish</code> procedure as follows:</p>
<pre class="hljs"><code><div><span class="hljs-comment"># Define a 'finish' procedure</span>
<span class="hljs-keyword">proc</span><span class="hljs-title"> finish</span> {} {
  <span class="hljs-keyword">global</span> ns tracefile1 namfile
  $ns <span class="hljs-keyword">flush</span>-<span class="hljs-keyword">trace</span>
  <span class="hljs-keyword">close</span> $tracefile1
  <span class="hljs-keyword">close</span> $namfile
  <span class="hljs-keyword">exec</span> nam out.nam &amp;
  <span class="hljs-keyword">exit</span> <span class="hljs-number">0</span>
}
</div></code></pre>
<p>The <code>proc</code> command declares a procedure called <code>finish</code>, which takes no arguments. The <code>global</code> command is used to indicate that variables declared outside the procedure will be used. The <code>flush-trace</code> method dumps the traces on the respective files, and the <code>close</code> command closes the trace files defined earlier. The <code>exec</code> command executes the <code>nam</code> program for visualization, and the <code>exit</code> command ends the application and returns the number <code>0</code> as a status to the system. At the end of the NS program, call the <code>finish</code> procedure and specify the time at which the termination should occur, as follows:</p>
<pre class="hljs"><code><div>$ns at <span class="hljs-number">125.0</span> <span class="hljs-string">"finish"</span>
</div></code></pre>
<p>This command connects nodes <code>$n0</code> and <code>$n2</code> using a bi-directional link with a propagation delay of 10ms and a capacity of 10Mb per second for each direction. To define a directional link instead of a bi-directional one, replace <code>duplex-link</code> with <code>simplex-link</code>.</p>
<p>To define an output queue of a node, include it as part of each link whose input is that node. The following command sets the buffer capacity of the queue related to a link:</p>
<pre class="hljs"><code><div><span class="hljs-comment"># Set Queue Size of link (n0-n2) to 20</span>
$ns queue-limit $n0 $n2 <span class="hljs-number">20</span>
</div></code></pre>
<p>To define routing (sources, destinations), agents (protocols), and applications that use them, follow the examples below.</p>
<p>For FTP over TCP:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">set</span> tcp [new Agent/TCP]
$ns attach-agent $n0 $tcp
<span class="hljs-keyword">set</span> sink [new Agent/TCPSink]
$ns attach-agent $n4 $sink
$ns connect $tcp $sink
$tcp <span class="hljs-keyword">set</span> fid_1
$tcp <span class="hljs-keyword">set</span> packetSize_ <span class="hljs-number">552</span>
</div></code></pre>
<p>For CBR over UDP:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">set</span> udp [new Agent/UDP] # Create a UDP agent
$ns attach-agent $n1 $udp # Define the <span class="hljs-keyword">source</span> node of the UDP connection
<span class="hljs-keyword">set</span> null [new Agent/Null]
$ns attach-agent $n5 $null
$ns connect $udp $null # Define the behavior of the destination node of UDP
$udp <span class="hljs-keyword">set</span> fid_2 # Set the flow identification of the UDP connection to '<span class="hljs-number">2</span>'
<span class="hljs-keyword">set</span> cbr [new Application/Traffic/CBR]
$cbr attach-agent $udp # Create a CBR application using the UDP agent
$cbr <span class="hljs-keyword">set</span> packetsize_ <span class="hljs-number">100</span>
$cbr <span class="hljs-keyword">set</span> rate_ <span class="hljs-number">0.01</span>Mb
$cbr <span class="hljs-keyword">set</span> random_ false # Define the destination node of the CBR application
$ns attach-agent $n4 $sink # Schedule the beginning and end of the CBR application
$ns at <span class="hljs-number">0.1</span> <span class="hljs-string">"$cbr start"</span>
$ns at <span class="hljs-number">124.5</span> <span class="hljs-string">"$cbr stop"</span>
</div></code></pre>
<p>To create a link between two nodes, use the <code>duplex-link</code> method of the simulator as follows:</p>
<pre class="hljs"><code><div>$ns duplex-link &lt;node1&gt; &lt;node2&gt; &lt;propagation delay&gt; &lt;queue&gt;
</div></code></pre>
<p>The <code>&lt;queue&gt;</code> argument is optional. If it is not specified, the link is assumed to have infinite capacity.
To schedule events, use the <code>at</code> method of the simulator as follows:</p>
<pre class="hljs"><code><div>$ns at &lt;<span class="hljs-keyword">time</span>&gt; &lt;event&gt;
</div></code></pre>
<h2 id="result">Result</h2>
<p>We have studied the Network Simulator 2 (NS2) in detail.</p>
<div style="page-break-after: always;"></div>
<!--
EXPERIMENT 6
Simulation of Distance Vector/Link State Routing.
a) Distance Vector routing protocol ROUTING
Aim:
To simulate and study the link state routing algorithm using simulation using NS2.
Routing is the process of selecting best paths in a network. In the past, the term
routing was also used to mean forwarding network traffic among networks. However this
latter function is muchbetter described as simply forwarding. Routing is performed for
many kinds of networks, including the telephone network (circuit switching), electronic
data networks (such as the Internet), and transportation networks. This article is concerned
primarily with routing in electronic data networks using packet switching technology
.In packet switching networks, routing directs packet forwarding (the transit of logically
addressed network packets from their source toward their ultimate destination) through
intermediate nodes. Intermediate nodes are typically network hardware devices such as
routers, bridges, gateways, firewalls, or switches. General-purpose computers can also
forward packets and perform routing, though they are not specialized hardware and may
suffer from limited performance. The routing process usually directs forwarding on the
basis of routing tables which maintain a record of the routes to various network destinations.
Thus, constructing routing tables, which are held in the router's memory, is very important
for efficient routing. Most routing algorithms use only one network path at a time.
Multipath routing techniques enable the use of multiple alternative paths. In case of
overlapping/equal routes, the following elements are considered in order to decide
which routes get installed into the routing table (sorted by priority):
1. Prefix-Length: where longer subnet masks are preferred (independent of whether it is
within a routing
protocol or over different routing protocol)
2. Metric: where a lower metric/cost is preferred (only valid within one and the same
routing protocol)
3. Administrative distance: where a lower distance is preferred (only valid between
different routing protocols) Routing, in a more narrow sense of the term, is often
contrasted with bridging in its assumption that network addresses are structured and that
similar addresses imply proximity within the network. Structured addresses allow a single
routing table entry to represent the route to a group of devices. In large networks,
Distance Vector routing protocol
structured addressing (routing, in the narrow sense) outperforms unstructured
addressing (bridging). Routing has become the dominant form of addressing on the
Internet. Bridging is still widely used within localized environments.
Algorithm
There are several variants of flooding algorithm. Most work roughly
as follows:
1. Each node acts as both a transmitter and a receiver.
2. Each node tries to forward every message to every one of its neighbours except the
source node. This results in every message eventually being delivered to all reachable
parts of the network. Algorithms may need to be more complex than this, since, in
some case, precautions have to be taken to avoid wasted duplicate deliveries and
infinite loops, and to allow messages to eventually expire from the system. A variant
of flooding called selective flooding partially addresses these issues by only sending
packets to routers in the same direction. In selective flooding the routers don't send
every incoming packet on every line but only on those lines which are going
approximately in the right direction.
Program:
set ns [new Simulator]
set nf [open out.nam w]
$ns namtrace-all $nf
set tr [open out.tr w]
$ns trace-all $tr
proc finish {} {
global nf ns tr
$ns flush-trace
close $tr
exec nam out.nam &
exit 0
}
set n0 [$ns node]
set n1 [$ns node]
set n2 [$ns node]
set n3 [$ns node]
$ns duplex-link $n0 $n1 10Mb 10ms DropTail
$ns duplex-link $n1 $n3 10Mb 10ms DropTail
$ns duplex-link $n2 $n1 10Mb 10ms DropTail
$ns duplex-link-op $n0 $n1 orient right-down
$ns duplex-link-op $n1 $n3 orient right
$ns duplex-link-op $n2 $n1 orient right-up
set tcp [new Agent/TCP]
$ns attach-agent $n0 $tcp
set ftp [new Application/FTP]
$ftp attach-agent $tcp
set sink [new Agent/TCPSink]
$ns attach-agent $n3 $sink
set udp [new Agent/UDP]
$ns attach-agent $n2 $udp
set cbr [new Application/Traffic/CBR]
$cbr attach-agent $udp
set null [new Agent/Null]
$ns attach-agent $n3 $null
$ns connect $tcp $sink
$ns connect $udp $null
$ns rtmodel-at 1.0 down $n1 $n3
$ns rtmodel-at 2.0 up $n1 $n3
$ns rtproto DV
$ns at 0.0 "$ftp start"
$ns at 0.0 "$cbr start"
$ns at 5.0 "finish"
$ns run
Result:
Thus the Distance Vector Routing Algorithm was Simulated and studied -->
<h1 id="experiment-6-a">Experiment 6 (a)</h1>
<h2 id="aim">Aim</h2>
<p>To simulate and study the Distance Vector routing algorithm using simulation using NS2.</p>
<h2 id="theory">Theory</h2>
<h3 id="introduction">Introduction</h3>
<p>Routing is the process of selecting the best paths in a network. In electronic data networks using packet switching technology, routing directs packet forwarding through intermediate nodes. Intermediate nodes are typically network hardware devices such as routers, bridges, gateways, firewalls, or switches. The routing process usually directs forwarding on the basis of routing tables which maintain a record of the routes to various network destinations. Most routing algorithms use only one network path at a time. However, multipath routing techniques enable the use of multiple alternative paths.</p>
<h3 id="algorithm">Algorithm</h3>
<p>The Distance Vector routing protocol works as follows:</p>
<ol>
<li>Each router maintains a table that lists the cost of reaching each destination network in the internetwork.</li>
<li>Each router periodically shares its routing table with its neighboring routers.</li>
<li>Each router updates its own routing table based on the information it receives from its neighbors.</li>
<li>The router selects the path with the lowest cost to the destination network as the best path.</li>
<li>The router forwards packets to the next hop router in the best path.</li>
</ol>
<h3 id="program">Program</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">set</span> ns [new Simulator]
<span class="hljs-keyword">set</span> nf [<span class="hljs-keyword">open</span> out.nam w]
$ns namtrace-all $nf
<span class="hljs-keyword">set</span> tr [<span class="hljs-keyword">open</span> out.tr w]
$ns <span class="hljs-keyword">trace</span>-all $tr

<span class="hljs-keyword">proc</span><span class="hljs-title"> finish</span> {} {
    <span class="hljs-keyword">global</span> nf ns tr
    $ns <span class="hljs-keyword">flush</span>-<span class="hljs-keyword">trace</span>
    <span class="hljs-keyword">close</span> $tr
    <span class="hljs-keyword">exec</span> nam out.nam &amp;
    <span class="hljs-keyword">exit</span> <span class="hljs-number">0</span>
}

<span class="hljs-keyword">set</span> n0 [$ns node]
<span class="hljs-keyword">set</span> n1 [$ns node]
<span class="hljs-keyword">set</span> n2 [$ns node]
<span class="hljs-keyword">set</span> n3 [$ns node]

$ns duplex-link $n0 $n1 <span class="hljs-number">10</span>Mb <span class="hljs-number">10</span>ms DropTail
$ns duplex-link $n1 $n3 <span class="hljs-number">10</span>Mb <span class="hljs-number">10</span>ms DropTail
$ns duplex-link $n2 $n1 <span class="hljs-number">10</span>Mb <span class="hljs-number">10</span>ms DropTail

$ns duplex-link-op $n0 $n1 orient right-down
$ns duplex-link-op $n1 $n3 orient right
$ns duplex-link-op $n2 $n1 orient right-up

<span class="hljs-keyword">set</span> tcp [new Agent/TCP]
$ns attach-agent $n0 $tcp

<span class="hljs-keyword">set</span> ftp [new Application/FTP]
$ftp attach-agent $tcp

<span class="hljs-keyword">set</span> sink [new Agent/TCPSink]
$ns attach-agent $n3 $sink

<span class="hljs-keyword">set</span> udp [new Agent/UDP]
$ns attach-agent $n2 $udp

<span class="hljs-keyword">set</span> cbr [new Application/Traffic/CBR]
$cbr attach-agent $udp

<span class="hljs-keyword">set</span> null [new Agent/Null]
$ns attach-agent $n3 $null

$ns connect $tcp $sink
$ns connect $udp $null

$ns rtmodel-at <span class="hljs-number">1.0</span> down $n1 $n3
$ns rtmodel-at <span class="hljs-number">2.0</span> up $n1 $n3

$ns rtproto DV

$ns at <span class="hljs-number">0.0</span> <span class="hljs-string">"$ftp start"</span>
$ns at <span class="hljs-number">0.0</span> <span class="hljs-string">"$cbr start"</span>
$ns at <span class="hljs-number">5.0</span> <span class="hljs-string">"finish"</span>

$ns run
</div></code></pre>
<h2 id="result">Result</h2>
<p>The Distance Vector Routing Algorithm was successfully simulated and studied using NS2.</p>
<div style="page-break-after: always;"></div>
<h1 id="experiment-6-b">Experiment 6 (b)</h1>
<h2 id="aim">Aim</h2>
<p>To simulate and study the Link State Routing algorithm using NS2.</p>
<h2 id="link-state-routing-protocol">Link State Routing Protocol</h2>
<p>In Link State Routing, each router shares its knowledge of its neighborhood with every other
router in the internetwork. The protocol works as follows:</p>
<ol>
<li>Knowledge about Neighborhood: Instead of sending its entire routing table, a router sends information about its neighborhood only.</li>
<li>To all Routers: Each router sends this information to every other router on the internet work, not just to its neighbor. It does so by a process called flooding.</li>
<li>Information sharing when there is a change: Each router sends out information about the neighbors when there is a change.</li>
</ol>
<h2 id="algorithm">Algorithm</h2>
<p>The following algorithm is used to simulate the Link State Routing protocol:</p>
<ol>
<li>Create a simulator object.</li>
<li>Define different colors for different data flows.</li>
<li>Open a nam trace file and define a finish procedure. Then close the trace file and execute nam on trace file.</li>
<li>Create n number of nodes using a for loop.</li>
<li>Create duplex links between the nodes.</li>
<li>Setup UDP Connection between n(0) and n(5).</li>
<li>Setup another UDP connection between n(1) and n(5).</li>
<li>Apply CBR Traffic over both UDP connections.</li>
<li>Choose Link State Routing protocol to transmit data from sender to receiver.</li>
<li>Schedule events and run the program.</li>
</ol>
<h2 id="program">Program</h2>
<pre class="hljs"><code><div><span class="hljs-keyword">set</span> ns [new Simulator]
<span class="hljs-keyword">set</span> nf [<span class="hljs-keyword">open</span> out.nam w]
$ns namtrace-all $nf
<span class="hljs-keyword">set</span> tr [<span class="hljs-keyword">open</span> out.tr w]
$ns <span class="hljs-keyword">trace</span>-all $tr

<span class="hljs-keyword">proc</span><span class="hljs-title"> finish</span> {} {
    <span class="hljs-keyword">global</span> nf ns tr
    $ns <span class="hljs-keyword">flush</span>-<span class="hljs-keyword">trace</span>
    <span class="hljs-keyword">close</span> $tr
    <span class="hljs-keyword">exec</span> nam out.nam &amp;
    <span class="hljs-keyword">exit</span> <span class="hljs-number">0</span>
}

<span class="hljs-keyword">set</span> n0 [$ns node]
<span class="hljs-keyword">set</span> n1 [$ns node]
<span class="hljs-keyword">set</span> n2 [$ns node]
<span class="hljs-keyword">set</span> n3 [$ns node]

$ns duplex-link $n0 $n1 <span class="hljs-number">10</span>Mb <span class="hljs-number">10</span>ms DropTail
$ns duplex-link $n1 $n3 <span class="hljs-number">10</span>Mb <span class="hljs-number">10</span>ms DropTail
$ns duplex-link $n2 $n1 <span class="hljs-number">10</span>Mb <span class="hljs-number">10</span>ms DropTail

$ns duplex-link-op $n0 $n1 orient right-down
$ns duplex-link-op $n1 $n3 orient right
$ns duplex-link-op $n2 $n1 orient right-up

<span class="hljs-keyword">set</span> tcp [new Agent/TCP]
$ns attach-agent $n0 $tcp

<span class="hljs-keyword">set</span> ftp [new Application/FTP]
$ftp attach-agent $tcp

<span class="hljs-keyword">set</span> sink [new Agent/TCPSink]
$ns attach-agent $n3 $sink

<span class="hljs-keyword">set</span> udp [new Agent/UDP]
$ns attach-agent $n2 $udp

<span class="hljs-keyword">set</span> cbr [new Application/Traffic/CBR]
$cbr attach-agent $udp

<span class="hljs-keyword">set</span> null [new Agent/Null]
$ns attach-agent $n3 $null

$ns connect $tcp $sink
$ns connect $udp $null

$ns rtmodel-at <span class="hljs-number">1.0</span> down $n1 $n3
$ns rtmodel-at <span class="hljs-number">2.0</span> up $n1 $n3

$ns rtproto LS

$ns at <span class="hljs-number">0.0</span> <span class="hljs-string">"$ftp start"</span>
$ns at <span class="hljs-number">0.0</span> <span class="hljs-string">"$cbr start"</span>
$ns at <span class="hljs-number">5.0</span> <span class="hljs-string">"finish"</span>

$ns run
</div></code></pre>
<h2 id="result">Result</h2>
<p>The Link State Routing Algorithm was successfully simulated and studied using NS2.</p>
<div style="page-break-after: always;"></div>
<h1 id="experiment-7">Experiment 7</h1>
<h2 id="aim">Aim</h2>
<p>To implement Stop and Wait Protocol and Sliding Window Protocol.</p>
<h2 id="stop-and-wait-protocol">Stop and Wait Protocol</h2>
<p>Stop and Wait Protocol is a flow control protocol in which a sender sends one packet of data to the receiver and then waits for an acknowledgment from the receiver.</p>
<h3 id="code">Code</h3>
<h4 id="sender">Sender</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> java.net.*;
<span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StopWaitSender</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> <span class="hljs-keyword">throws</span> Exception </span>{
        StopWaitSender sws = <span class="hljs-keyword">new</span> StopWaitSender();
        sws.run();
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);
        System.out.println(<span class="hljs-string">"Enter no of frames to be sent:"</span>);
        <span class="hljs-keyword">int</span> n = sc.nextInt();
        Socket myskt = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">9999</span>);
        PrintStream myps = <span class="hljs-keyword">new</span> PrintStream(myskt.getOutputStream());
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n;) {
            <span class="hljs-keyword">if</span> (i == n) {
                myps.println(<span class="hljs-string">"exit"</span>);
                <span class="hljs-keyword">break</span>;
            }
            System.out.println(<span class="hljs-string">"Frame no "</span> + i + <span class="hljs-string">" is sent"</span>);
            myps.println(i);
            BufferedReader bf = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(myskt.getInputStream()));
            String ack = bf.readLine();

            <span class="hljs-keyword">if</span> (ack != <span class="hljs-keyword">null</span>) {
                System.out.println(<span class="hljs-string">"Acknowledgement was Received from receiver"</span>);
                i++;
                Thread.sleep(<span class="hljs-number">4000</span>);
            } <span class="hljs-keyword">else</span> {
                myps.println(i);
            }
        }
    }
}
</div></code></pre>
<h4 id="receiver">Receiver</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> java.net.*;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StopWaitReceiver</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> <span class="hljs-keyword">throws</span> Exception </span>{
        StopWaitReceiver swr = <span class="hljs-keyword">new</span> StopWaitReceiver();
        swr.run();
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
        String temp = <span class="hljs-string">"any message"</span>;
        String str = <span class="hljs-string">"exit"</span>;
        ServerSocket myss = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">9999</span>);
        Socket ss_accept = myss.accept();
        BufferedReader ss_bf = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(ss_accept.getInputStream()));
        PrintStream myps = <span class="hljs-keyword">new</span> PrintStream(ss_accept.getOutputStream());

        <span class="hljs-keyword">while</span> (temp.compareTo(str) != <span class="hljs-number">0</span>) {
            Thread.sleep(<span class="hljs-number">1000</span>);
            temp = ss_bf.readLine();
            <span class="hljs-keyword">if</span> (temp.compareTo(str) == <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">break</span>;
            }
            System.out.println(<span class="hljs-string">"Frame "</span> + temp + <span class="hljs-string">" was received"</span>);
            Thread.sleep(<span class="hljs-number">500</span>);
            myps.println(<span class="hljs-string">"Received"</span>);
        }

        System.out.println(<span class="hljs-string">"ALL FRAMES WERE RECEIVED SUCCESSFULLY"</span>);
    }
}
</div></code></pre>
<h3 id="output">Output</h3>
<h4 id="sender">Sender</h4>
<pre class="hljs"><code><div>Enter no of frames to be sent:
4
Frame no 0 is sent
Acknowledgement was Received from receiver
Frame no 1 is sent
Acknowledgement was Received from receiver
Frame no 2 is sent
Acknowledgement was Received from receiver
Frame no 3 is sent
Acknowledgement was Received from receiver
</div></code></pre>
<h4 id="receiver">Receiver</h4>
<pre class="hljs"><code><div>Frame 0 was received
Frame 1 was received
Frame 2 was received
Frame 3 was received
ALL FRAMES WERE RECEIVED SUCCESSFULLY
</div></code></pre>
<h2 id="sliding-window-protocol">Sliding Window Protocol</h2>
<p>Sliding Window Protocol is a flow control protocol in which a sender sends multiple packets to the receiver before receiving the acknowledgment of the first few packets.</p>
<h3 id="code">Code</h3>
<h4 id="bit-client">Bit Client</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.net.*;
<span class="hljs-keyword">import</span> java.io.*;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BitClient</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">try</span> {
            BufferedInputStream in;
            ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">500</span>);
            System.out.println(<span class="hljs-string">"Waiting for connection"</span>);
            Socket client = serverSocket.accept();
            System.out.println(<span class="hljs-string">"Received request for sending frames"</span>);
            in = <span class="hljs-keyword">new</span> BufferedInputStream(client.getInputStream());
            DataOutputStream out = <span class="hljs-keyword">new</span> DataOutputStream(client.getOutputStream());
            <span class="hljs-keyword">int</span> p = in.read();
            System.out.println(<span class="hljs-string">"Sending .... "</span>);

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= p; ++i) {
                System.out.println(<span class="hljs-string">"Sending frame no "</span> + i);
                out.write(i);
                out.flush();
                System.out.println(<span class="hljs-string">"Waiting for acknowledge"</span>);
                Thread.sleep(<span class="hljs-number">5000</span>);
                <span class="hljs-keyword">int</span> a = in.read();
                System.out.println(<span class="hljs-string">"Received acknowledge for frame no: "</span> + i + <span class="hljs-string">" as "</span> + a);
            }

            out.flush();
            in.close();
            out.close();
            client.close();
            serverSocket.close();
            System.out.println(<span class="hljs-string">"Quiting"</span>);
        } <span class="hljs-keyword">catch</span> (IOException e) {
            System.out.println(e);
        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
        }
    }
}
</div></code></pre>
<h4 id="bit-server">Bit Server</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.lang.System;
<span class="hljs-keyword">import</span> java.net.*;
<span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> java.math.*;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BitServer</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String a[])</span> </span>{
        <span class="hljs-keyword">try</span> {
            InetAddress addr = InetAddress.getByName(<span class="hljs-string">"localhost"</span>);
            System.out.println(addr);
            Socket connection = <span class="hljs-keyword">new</span> Socket(addr, <span class="hljs-number">500</span>);
            DataOutputStream out = <span class="hljs-keyword">new</span> DataOutputStream(connection.getOutputStream());
            BufferedInputStream in = <span class="hljs-keyword">new</span> BufferedInputStream(connection.getInputStream());
            BufferedInputStream inn = <span class="hljs-keyword">new</span> BufferedInputStream(connection.getInputStream());
            BufferedReader ki = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));
            <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;
            System.out.println(<span class="hljs-string">"Connect"</span>);
            System.out.println(<span class="hljs-string">"Enter the no of frames to be requested to server:"</span>);
            <span class="hljs-keyword">int</span> c = Integer.parseInt(ki.readLine());
            out.write(c);
            out.flush();
            <span class="hljs-keyword">int</span> i, jj = <span class="hljs-number">0</span>;

            <span class="hljs-keyword">while</span> (jj &lt; c) {
                i = in.read();
                System.out.println(<span class="hljs-string">"Received frame no "</span> + i);
                System.out.println(<span class="hljs-string">"Sending acknowledgement for frame no "</span> + i);
                out.write(i);
                out.flush();
                jj++;
            }

            out.flush();
            in.close();
            inn.close();
            out.close();

            System.out.println(<span class="hljs-string">"Output:"</span>);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }
    }
}
</div></code></pre>
<h3 id="output">Output</h3>
<h4 id="bit-client">Bit Client</h4>
<pre class="hljs"><code><div>Waiting for connection
Received request for sending frames
Sending ....
Sending frame no 1
Waiting for acknowledge
Received acknowledge for frame no: 1 as 1
Sending frame no 2
Waiting for acknowledge
Received acknowledge for frame no: 2 as 2
Sending frame no 3
Waiting for acknowledge
Received acknowledge for frame no: 3 as 3
Sending frame no 4
Waiting for acknowledge
Received acknowledge for frame no: 4 as 4
Quiting
</div></code></pre>
<h4 id="bit-server">Bit Server</h4>
<pre class="hljs"><code><div>localhost/127.0.0.1
Connect
Enter the no of frames to be requested to server:
4
Received frame no 1
Sending acknowledgement for frame no 1
Received frame no 2
Sending acknowledgement for frame no 2
Received frame no 3
Sending acknowledgement for frame no 3
Received frame no 4
Sending acknowledgement for frame no 4
Output:
</div></code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>Thus, we have studied the various types of flow control protocols and implemented them using Java.</p>
<div style="page-break-after: always;"></div>
<!-- EXPERIMENT 8
Study of Socket Programming and Client â€“ Server model
Java Socket programming is used for communication between the applications running on
different JRE. Java Socket programming can be connection-oriented or connection-less. The
client in socket programming must know two information: IP Address of Server, and Port
number.
Here, we are going to make one-way client and server communication. In this application,
client sends a message to the server, server reads the message and prints it. Here, two classes
are being used: Socket and ServerSocket. The Socket class is used to communicate client and
server. Through this class, we can read and write message. The ServerSocket class is used at
server-side. The accept() method of ServerSocket class blocks the console until the client is
connected. After the successful connection of client, it returns the instance of Socket at serverside.
Socket class
A socket is simply an endpoint for communications between the machines. The Socket class
can be used to create a socket.
Important methods
Method Description
1) public InputStream getInputStream() returns the InputStream attached with this socket.
2)public OutputStream getOutputStream() returns the OutputStream attached with this socket.
3) public synchronized void close() closes this socket
ServerSocket class
The ServerSocket class can be used to create a server socket. This object is used to establish
communication with the clients.
Important methods
Method Description
1) public Socket accept() returns the socket and establish a connection between server and
client.
2) public
close()
synchronized void closes the server socket.
Example of Java Socket Programming
Creating Server:
To create the server application, we need to create the instance of ServerSocket class. Here,
we are using 6666 port number for the communication between the client and server. You
may also choose any other port number. The accept() method waits for the client. If clients
connects with the given port number, it returns an instance of Socket.
1. ServerSocket ss=new ServerSocket(6666);
2. Socket s=ss.accept();//establishes connection and waits for the client
Creating Client:
To create the client application, we need to create the instance of Socket class. Here, we need
to pass the IP address or hostname of the Server and a port number. Here, we are using
"localhost" because our server is running on same system.
1. Socket s=new Socket("localhost",6666);
Let's see a simple of Java socket programming where client sends a text and server receives
and prints it.
File: MyServer.java
import java.io.*;
import java.net.*;
File: MyClient.java
import java.io.*;
import java.net.*;
public class MyServer {
public static void main(String[] args){
try{
ServerSocket ss=new ServerSocket(6666);
Socket s=ss.accept();//establishes connection
public class MyClient {
public static void main(String[] args) {
try{
Socket s=new Socket("localhost",6666);
DataInputStream dis=new
DataInputStream(s.getInputStream());
DataOutputStream dout=new
DataOutputStream(s.getOutputStream());
String str=(String)dis.readUTF();
System.out.println("message= "+str);
dout.writeUTF("Hello Server");
dout.flush();
ss.close();
dout.close();
s.close();
}catch(Exception e){System.out.println(e);}
}
}
}catch(Exception e){System.out.println(e);}
}
}
 -->
<h1 id="experiment-8">EXPERIMENT 8</h1>
<h2 id="aim">Aim</h2>
<p>The aim of this experiment is to study Socket Programming and Client-Server model.</p>
<h2 id="introduction">Introduction</h2>
<p>Java Socket programming is used for communication between the applications running on different JRE. Java Socket programming can be connection-oriented or connection-less. The client in socket programming must know two pieces of information: IP address of the server and port number. Here, we are going to make one-way client and server communication. In this application, the client sends a message to the server, the server reads the message, and prints it.</p>
<h2 id="socket-class">Socket Class</h2>
<p>A socket is simply an endpoint for communications between machines. The Socket class can be used to create a socket. Important methods include:</p>
<ul>
<li><code>public InputStream getInputStream()</code>: returns the InputStream attached with this socket.</li>
<li><code>public OutputStream getOutputStream()</code>: returns the OutputStream attached with this socket.</li>
<li><code>public synchronized void close()</code>: closes this socket.</li>
</ul>
<h2 id="serversocket-class">ServerSocket Class</h2>
<p>The ServerSocket class can be used to create a server socket. This object is used to establish communication with clients. Important methods include:</p>
<ul>
<li><code>public Socket accept()</code>: returns the socket and establish a connection between server and client.</li>
<li><code>public synchronized void close()</code>: closes the server socket.</li>
</ul>
<h2 id="code">Code</h2>
<h3 id="serverjava">Server.java</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> java.net.*;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">try</span> {
            ServerSocket ss = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);
            Socket s = ss.accept(); <span class="hljs-comment">// establishes connection</span>
            DataInputStream dis = <span class="hljs-keyword">new</span> DataInputStream(s.getInputStream());
            String str = (String) dis.readUTF();
            System.out.println(<span class="hljs-string">"message= "</span> + str);
            ss.close();
        } <span class="hljs-keyword">catch</span> (Exception e) {
            System.out.println(e);
        }
    }
}
</div></code></pre>
<h3 id="clientjava">Client.java</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> java.net.*;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">try</span> {
            Socket s = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">6666</span>);
            DataOutputStream dout = <span class="hljs-keyword">new</span> DataOutputStream(s.getOutputStream());
            dout.writeUTF(<span class="hljs-string">"Hello Server"</span>);
            dout.flush();
            dout.close();
            s.close();
        } <span class="hljs-keyword">catch</span> (Exception e) {
            System.out.println(e);
        }
    }
}
</div></code></pre>
<h2 id="output">Output</h2>
<h3 id="server">Server</h3>
<p><img src="https://i.imgur.com/TlVncPl.png" alt="Server"></p>
<h3 id="client">Client</h3>
<p><img src="https://i.imgur.com/qxbAaGs.png" alt="Client"></p>
<h2 id="conclusion">Conclusion</h2>
<p>Thus, we have studied Socket Programming and Client-Server model in Java. Socket programming provides a way to communicate between different applications running on different JRE. It is important to establish a connection between the client and server, and properly handle the input and output streams.</p>
<div style="page-break-after: always;"></div>
<!-- EXPERIMENT 9
Write a code simulating ARP /RARP protocols.
This program automatically creates a file with the IP address of machines, their MAC address
and type.
ARP protocol is simulated by reading an IP address and returning the MAC address. RARP
protocol is simulated by reading an MAC address and returning the IP address
The program can be extended to read an IP Address / Mac Address and a message and send a
packet to the specified machine using TCP / IP or Datagram sockets
import java.io.*;
import java.util.*;
public class arp_rarp
{
private static final String Command = "arp -a";
public static void getARPTable(String cmd) throws Exception
{
File fp = new File("ARPTable.txt");
FileWriter fw = new FileWriter(fp);
BufferedWriter bw = new BufferedWriter(fw);
Process P = Runtime.getRuntime().exec(cmd);
Scanner S = new Scanner(P.getInputStream()).useDelimiter("\\A");
while(S.hasNext())
bw.write(S.next());
bw.close();
fw.close();
}
public static void findMAC(String ip) throws Exception
{
File fp = new File("ARPTable.txt");
FileReader fr = new FileReader(fp);
BufferedReader br = new BufferedReader(fr);
String line;
while ((line = br.readLine()) != null)
{
if (line.contains(ip))
{
System.out.println("Internet Address Physical Address Type");
System.out.println(line);
break;
}
}
if((line == null))
System.out.println("Not found");
fr.close();
br.close();
}
public static void findIP(String mac) throws Exception
{
File fp = new File("ARPTable.txt");
FileReader fr = new FileReader(fp);
BufferedReader br = new BufferedReader(fr);
String line;
while ((line = br.readLine()) != null)
{
if (line.contains(mac))
{
System.out.println("Internet Address Physical Address Type");
System.out.println(line);
break;
}
}
if((line == null))
System.out.println("Not found");
fr.close();
br.close();
}
public static void main(String as[]) throws Exception
{
getARPTable(Command);
Scanner S = new Scanner(System.in);
System.out.println("ARP Protocol.");
System.out.print("Enter IP Address: ");
String IP = S.nextLine();
findMAC(IP);
System.out.println("RARP Protocol.");
System.out.print("Enter MAC Address: ");
String MAC = S.nextLine();
findIP(MAC);
}
}
OUTPUT:
>javac arp_rarp.java
>java arp_rarp
ARP Protocol.
Enter IP Address: 10.0.15.253
Internet Address Physical Address Type
10.0.15.253 00-16-76-bd-41-27 dynamic
RARP Protocol.
Enter MAC Address: 01-00-5e-00-00-fc
Internet Address Physical Address Type
224.0.0.252 01-00-5e-00-00-fc static
>java arp_rarp
ARP Protocol.
Enter IP Address: 10.0.15.121
Not found
RARP Protocol.
Enter MAC Address: 01-00-5e-00-00-ff
Not found
ARPTable.txt
Interface: 10.0.15.202 --- 0x3
Internet Address Physical Address Type
10.0.15.1 54-78-1a-1e-6a-4f dynamic
10.0.15.72 00-13-20-b7-49-c9 dynamic
10.0.15.253 00-16-76-bd-41-27 dynamic
10.0.15.255 ff-ff-ff-ff-ff-ff static
224.0.0.22 01-00-5e-00-00-16 static
224.0.0.251 01-00-5e-00-00-fb static
224.0.0.252 01-00-5e-00-00-fc static
239.255.255.250 01-00-5e-7f-ff-fa static
 -->
<h1 id="experiment-9">EXPERIMENT 9</h1>
<h2 id="aim">Aim</h2>
<p>The aim of this experiment is to simulate ARP / RARP protocols using Java programming language.</p>
<h2 id="theory">Theory</h2>
<p>ARP (Address Resolution Protocol) is used to translate the IP address of a host to its corresponding MAC (Media Access Control) address. RARP (Reverse Address Resolution Protocol) is used to translate the MAC address of a host to its corresponding IP address. In this experiment, we will write a Java program that simulates ARP and RARP protocols. This program will automatically create a file with the IP address of machines, their MAC address, and type.</p>
<h2 id="code">Code</h2>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> java.util.*;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">arp_rarp</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String Command = <span class="hljs-string">"arp -a"</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getARPTable</span><span class="hljs-params">(String cmd)</span> <span class="hljs-keyword">throws</span> Exception </span>{
        File fp = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"ARPTable.txt"</span>);
        FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(fp);
        BufferedWriter bw = <span class="hljs-keyword">new</span> BufferedWriter(fw);
        Process P = Runtime.getRuntime().exec(cmd);
        Scanner S = <span class="hljs-keyword">new</span> Scanner(P.getInputStream()).useDelimiter(<span class="hljs-string">"\\A"</span>);
        <span class="hljs-keyword">while</span> (S.hasNext())
            bw.write(S.next());
        bw.close();
        fw.close();
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findMAC</span><span class="hljs-params">(String ip)</span> <span class="hljs-keyword">throws</span> Exception </span>{
        File fp = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"ARPTable.txt"</span>);
        FileReader fr = <span class="hljs-keyword">new</span> FileReader(fp);
        BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(fr);
        String line;
        <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">if</span> (line.contains(ip)) {
                System.out.println(<span class="hljs-string">"Internet Address Physical Address Type"</span>);
                System.out.println(line);
                <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-keyword">if</span> ((line == <span class="hljs-keyword">null</span>))
            System.out.println(<span class="hljs-string">"Not found"</span>);
        fr.close();
        br.close();
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findIP</span><span class="hljs-params">(String mac)</span> <span class="hljs-keyword">throws</span> Exception </span>{
        File fp = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"ARPTable.txt"</span>);
        FileReader fr = <span class="hljs-keyword">new</span> FileReader(fp);
        BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(fr);
        String line;
        <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">if</span> (line.contains(mac)) {
                System.out.println(<span class="hljs-string">"Internet Address Physical Address Type"</span>);
                System.out.println(line);
                <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-keyword">if</span> ((line == <span class="hljs-keyword">null</span>))
            System.out.println(<span class="hljs-string">"Not found"</span>);
        fr.close();
        br.close();
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String as[])</span> <span class="hljs-keyword">throws</span> Exception </span>{
        getARPTable(Command);
        Scanner S = <span class="hljs-keyword">new</span> Scanner(System.in);
        System.out.println(<span class="hljs-string">"ARP Protocol."</span>);
        System.out.print(<span class="hljs-string">"Enter IP Address: "</span>);
        String IP = S.nextLine();
        findMAC(IP);
        System.out.println(<span class="hljs-string">"RARP Protocol."</span>);
        System.out.print(<span class="hljs-string">"Enter MAC Address: "</span>);
        String MAC = S.nextLine();
        findIP(MAC);
    }
}
</div></code></pre>
<h3 id="arptabletxt">ARPTable.txt</h3>
<pre class="hljs"><code><div>Interface: 192.168.1.10 --- 0x2
  Internet Address      Physical Address      Type
  192.168.1.1           00-0e-2e-5c-7a-0a     dynamic
  192.168.1.2           00-15-c5-4b-8f-2f     dynamic
  192.168.1.5           00-21-cc-f8-5e-2f     dynamic
  192.168.1.7           00-1d-d9-b1-7e-50     dynamic
</div></code></pre>
<h2 id="output">Output</h2>
<p><a href="https://i.imgur.com/o31oIxM.png">output</a></p>
<h2 id="conclusion">Conclusion</h2>
<p>In this experiment, we have learned about ARP and RARP protocols and how they can be simulated using Java programming language. The program automatically creates a file with the IP address of machines, their MAC address, and type. The program can also be extended to read an IP Address / Mac Address and a message and send a packet to the specified machine using TCP / IP or Datagram sockets.</p>
<div style="page-break-after: always;"></div>
<!-- EXPERIMENT 10
(a) Write a code simulating PING commands
Algorithm
Step 1: start the program.
Step 2: Include necessary package in java.
Step 3: To create a process object p to implement the ping command.
Step 4: declare one BufferedReader stream class object.
Step 5: Get thedetails of the server
5.1: length of the IP address.
5.2: time required to get the details.
5.3: send packets , receive packets and lost packets.
5.4: minimum ,maximum and average times.
Step 6: print the results.
Step 7:Stop the program.
Program:
import java.io.*;
import java.net.*;
class pingserver
{
public static void main(String args[])
{
try
{
String str;
System.out.print(" Enter the IP Address to be Ping : ");
BufferedReader buf1=new BufferedReader(new
InputStreamReader(System.in));
String ip=buf1.readLine();
Runtime H=Runtime.getRuntime();
Process p=H.exec("ping " + ip);
InputStream in=p.getInputStream();
BufferedReader buf2=new BufferedReader(new
InputStreamReader(in));
while((str=buf2.readLine())!=null)
{
System.out.println(" " + str);
}
}
catch(Exception e)
{
System.out.println(e.getMessage());
}
}
}
Output:
Enter the IP address to the ping:192.168.0.1
Pinging 192.168.0.1: with bytes of data =32
Reply from 192.168.0.11:bytes=32 time<1ms TTL =128
Reply from 192.168.0.11:bytes=32 time<1ms TTL =128
Reply from 192.168.0.11:bytes=32 time<1ms TTL =128
Reply from 192.168.0.11:bytes=32 time<1ms TTL =128
Ping statistics for 192.168.0.1
Packets: sent=4,received=4,lost=0(0% loss),approximate round trip time in milli seconds:
Minimum=1
ms,maximum=4ms,average=2ms -->
<h1 id="experiment-10-a">EXPERIMENT 10 (a)</h1>
<h2 id="aim">Aim</h2>
<p>The aim of this experiment is to write a Java program that simulates the PING command.</p>
<h2 id="algorithm">Algorithm</h2>
<ol>
<li>Start the program.</li>
<li>Import necessary packages in Java.</li>
<li>Create a Process object to implement the PING command.</li>
<li>Declare a BufferedReader stream class object.</li>
<li>Get the details of the server:
<ol>
<li>Length of the IP address.</li>
<li>Time required to get the details.</li>
<li>Send packets, receive packets, and lost packets.</li>
<li>Minimum, maximum, and average times.</li>
</ol>
</li>
<li>Print the results.</li>
<li>Stop the program.</li>
</ol>
<h2 id="code">Code</h2>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> java.net.*;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">pingserver</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>{
        <span class="hljs-keyword">try</span> {
            String str;
            System.out.print(<span class="hljs-string">"Enter the IP Address to be Ping: "</span>);
            BufferedReader buf1 = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));
            String ip = buf1.readLine();
            Runtime H = Runtime.getRuntime();
            Process p = H.exec(<span class="hljs-string">"ping "</span> + ip);
            InputStream in = p.getInputStream();
            BufferedReader buf2 = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(in));
            <span class="hljs-keyword">while</span> ((str = buf2.readLine()) != <span class="hljs-keyword">null</span>) {
                System.out.println(<span class="hljs-string">" "</span> + str);
            }
        } <span class="hljs-keyword">catch</span> (Exception e) {
            System.out.println(e.getMessage());
        }
    }
}
</div></code></pre>
<h2 id="output">Output</h2>
<pre class="hljs"><code><div>Enter the IP Address to be Ping: 192.168.0.1
Pinging 192.168.0.1: with bytes of data =32
Reply from 192.168.0.11: bytes=32 time&lt;1ms TTL=128
Reply from 192.168.0.11: bytes=32 time&lt;1ms TTL=128
Reply from 192.168.0.11: bytes=32 time&lt;1ms TTL=128
Reply from 192.168.0.11: bytes=32 time&lt;1ms TTL=128

Ping statistics for 192.168.0.1:
    Packets: sent=4, received=4, lost=0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 1ms, Maximum = 4ms, Average = 2ms
</div></code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>In this experiment, we have learned how to simulate the PING command using Java programming language. The program prompts the user to enter an IP address and then sends PING packets to the specified IP address. The program then receives and displays the response from the IP address, including details such as the time it took to receive a response, the number of packets sent and received, and the percentage of packets lost. The program can be useful for network troubleshooting and testing.</p>
<div style="page-break-after: always;"></div>
<!-- EXPERIMENT 10 (b)
Write a code simulating Traceroute commands
import java.io.BufferedReader;
import java.io.InputStreamReader;
public class traceroutecmd
{
public static void runSystemCommand(String command)
{
try
{
Process p = Runtime.getRuntime().exec(command);
BufferedReader inputStream = new BufferedReader(
new InputStreamReader(p.getInputStream()));
String s = "";
while ((s = inputStream.readLine()) != null)
System.out.println(s);
}
catch (Exception e)
{
}
}
public static void main(String[] args)
{
// String ip = "www.google.co.in";
// String ip = "127.0.0.1";
String ip = "www.drranurekha.com";
runSystemCommand("tracert " + ip);
}
}
OUTPUT:
>javac traceroutecmd.java
>java traceroutecmd
Tracing route to drranurekha.com [160.153.137.167] over a maximum of 30 hops:
1 <1 ms <1 ms <1 ms 10.0.15.1
2 <1 ms <1 ms <1 ms 10.0.0.15
3 1 ms 1 ms 1 ms 210.212.247.209
4 2 ms 1 ms 1 ms 172.24.75.102
5 * * 21 ms 218.248.235.217
6 * * 12 ms 218.248.235.218
7 21 ms 21 ms 21 ms 121.244.37.253.static.chennai.vsnl.net.in [121.244.37.253]
8 * * * Request timed out.
9 49 ms 49 ms 49 ms 172.25.81.134
10 50 ms 50 ms 70 ms ix-ae-0-4.tcore1.mlv-mumbai.as6453.net [180.87.38.5]
11 165 ms 165 ms 165 ms if-ae-9-5.tcore1.wyn-marseille.as6453.net [80.231.217.17]
12 172 ms 171 ms 171 ms if-ae-8-1600.tcore1.pye-paris.as6453.net [80.231.217.6]
13 171 ms 171 ms 171 ms if-ae-15-2.tcore1.av2-amsterdam.as6453.net
[195.219.194.145]
14 175 ms 175 ms 175 ms 195.219.194.2
15 171 ms 170 ms 170 ms po72.bbsa0201-01.bbn.mgmt.ams1.gdg [188.121.33.74]
16 170 ms 169 ms 169 ms 10.241.131.203
17 175 ms 175 ms 175 ms 10.253.1.1
18 166 ms 166 ms 166 ms 10.253.130.9
19 173 ms 173 ms 173 ms 10.253.130.3
20 169 ms 169 ms 169 ms 10.253.130.5
21 169 ms 169 ms 169 ms ip-160-153-137-167.ip.secureserver.net [160.153.137.167]
Trace complete -->
<h1 id="experiment-10-b">EXPERIMENT 10 (b)</h1>
<h2 id="aim">Aim</h2>
<p>The aim of this experiment is to write a Java program that simulates the TRACERT command.</p>
<h2 id="algorithm">Algorithm</h2>
<ol>
<li>Start the program.</li>
<li>Import necessary packages in Java.</li>
<li>Create a method to run system commands.</li>
<li>Create a main method to execute the TRACERT command.</li>
<li>Prompt the user to enter a domain name or IP address to trace the route to.</li>
<li>Execute the TRACERT command using the runSystemCommand method.</li>
<li>Print the results.</li>
<li>Stop the program.</li>
</ol>
<h2 id="code">Code</h2>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.io.BufferedReader;
<span class="hljs-keyword">import</span> java.io.InputStreamReader;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">traceroutecmd</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runSystemCommand</span><span class="hljs-params">(String command)</span> </span>{
        <span class="hljs-keyword">try</span> {
            Process p = Runtime.getRuntime().exec(command);
            BufferedReader inputStream = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(p.getInputStream()));
            String s = <span class="hljs-string">""</span>;
            <span class="hljs-keyword">while</span> ((s = inputStream.readLine()) != <span class="hljs-keyword">null</span>)
                System.out.println(s);
        } <span class="hljs-keyword">catch</span> (Exception e) {
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        String ip = <span class="hljs-string">"www.drranurekha.com"</span>;
        System.out.println(<span class="hljs-string">"Tracing route to "</span> + ip + <span class="hljs-string">" over a maximum of 30 hops:"</span>);
        runSystemCommand(<span class="hljs-string">"tracert "</span> + ip);
    }
}
</div></code></pre>
<h2 id="output">Output</h2>
<pre class="hljs"><code><div>Tracing route to drranurekha.com [160.153.137.167] over a maximum of 30 hops:
  1    &lt;1 ms    &lt;1 ms    &lt;1 ms  10.0.15.1
  2    &lt;1 ms    &lt;1 ms    &lt;1 ms  10.0.0.15
  3     1 ms     1 ms     1 ms  210.212.247.209
  4     2 ms     1 ms     1 ms  172.24.75.102
  5    *        *       21 ms  218.248.235.217
  6    *        *       12 ms  218.248.235.218
  7    21 ms    21 ms    21 ms  121.244.37.253.static.chennai.vsnl.net.in [121.244.37.253]
  8    *        *        *     Request timed out.
  9    49 ms    49 ms    49 ms  172.25.81.134
 10    50 ms    50 ms    70 ms  ix-ae-0-4.tcore1.mlv-mumbai.as6453.net [180.87.38.5]
 11   165 ms   165 ms   165 ms  if-ae-9-5.tcore1.wyn-marseille.as6453.net [80.231.217.17]
 12   172 ms   171 ms   171 ms  if-ae-8-1600.tcore1.pye-paris.as6453.net [80.231.217.6]
 13   171 ms   171 ms   171 ms  if-ae-15-2.tcore1.av2-amsterdam.as6453.net [195.219.194.145]
 14   175 ms   175 ms   175 ms  195.219.194.2
 15   171 ms   170 ms   170 ms  po72.bbsa0201-01.bbn.mgmt.ams1.gdg [188.121.33.74]
 16   170 ms   169 ms   169 ms  10.241.131.203
 17   175 ms   175 ms   175 ms  10.253.1.1
 18   166 ms   166 ms   166 ms  10.253.130.9
 19   173 ms   173 ms   173 ms  10.253.130.3
 20   169 ms   169 ms   169 ms  10.253.130.5
 21   169 ms   169 ms   169 ms  ip-160-153-137-167.ip.secureserver.net [160.153.137.167]

Trace complete.
</div></code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>In this experiment, we have learned how to simulate the TRACERT command using Java programming language. The program prompts the user to enter a domain name or IP address to trace the route to and then executes the TRACERT command using the runSystemCommand method. The program then receives and displays the response from the specified domain name or IP address, including details such as the number of hops, the time it took to reach each hop, and the IP address of each hop. The program can be useful for network troubleshooting and testing.</p>
<div style="page-break-after: always;"></div>
<!-- EXPERIMENT 11
Create a socket for HTTP for web page upload and download.
Algorithm
1.Start the program.
2.Get the frame size from the user
3.To create the frame based on the user request.
4.To send frames to server from the client side.
5.If your frames reach the server it will send ACK signal to client otherwise it will send
NACK signal to client.
6.Stop the program
Program :
Client
import javax.swing.*;
import java.net.*;
import java.awt.image.*;
import javax.imageio.*;
import java.io.*;
import java.awt.image.BufferedImage; import java.io.ByteArrayOutputStream; import
java.io.File;
import java.io.IOException; import javax.imageio.ImageIO;
public class Client{
public static void main(String args[]) throws Exception{ Socket soc;
BufferedImage img = null;
soc=new Socket("localhost",4000);
System.out.println("Client is running. ");
try {
System.out.println("Reading image from disk. ");
img = ImageIO.read(new File("digital_image_processing.jpg")); ByteArrayOutputStream
baos = new ByteArrayOutputStream();
ImageIO.write(img, "jpg", baos);
baos.flush();
byte[] bytes = baos.toByteArray(); baos.close();
System.out.println("Sending image to server. ");
OutputStream out = soc.getOutputStream();
DataOutputStream dos = new DataOutputStream(out);
dos.writeInt(bytes.length);
dos.write(bytes, 0, bytes.length);
System.out.println("Image sent to server. ");
dos.close();
out.close();
}catch (Exception e) { System.out.println("Exception: " + e.getMessage());
soc.close();
}
soc.close();
}
}
Server
import java.net.*;
import java.io.*;
import java.awt.image.*;
import javax.imageio.*;
import javax.swing.*;
class Server {
public static void main(String args[]) throws Exception{
ServerSocket server=null;
Socket socket;
server=new ServerSocket(4000);
System.out.println("Server Waiting for image");
socket=server.accept(); System.out.println("Client connected.");
InputStream in = socket.getInputStream();
DataInputStream dis = new DataInputStream(in);
int len = dis.readInt();
System.out.println("Image Size: " + len/1024 + "KB"); byte[] data = new byte[len];
dis.readFully(data);
dis.close();
in.close();
InputStream ian = new ByteArrayInputStream(data);
BufferedImage bImage = ImageIO.read(ian);
JFrame f = new JFrame("Server");
ImageIcon icon = new ImageIcon(bImage);
JLabel l = new JLabel();
l.setIcon(icon);
f.add(l);
f.pack();
f.setVisible(true); } }

-->
<h1 id="experiment-11">EXPERIMENT 11</h1>
<h2 id="aim">Aim</h2>
<p>The aim of this experiment is to create a socket for HTTP for web page upload and download.</p>
<h2 id="algorithm">Algorithm</h2>
<ol>
<li>Start the program.</li>
<li>Get the frame size from the user.</li>
<li>Create the frame based on the user request.</li>
<li>Send frames to the server from the client side.</li>
<li>If the frames reach the server, it will send an ACK signal to the client; otherwise, it will send a NACK signal to the client.</li>
<li>Stop the program.</li>
</ol>
<h2 id="code">Code</h2>
<h3 id="client">Client</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> javax.swing.*;
<span class="hljs-keyword">import</span> java.net.*;
<span class="hljs-keyword">import</span> java.awt.image.*;
<span class="hljs-keyword">import</span> javax.imageio.*;
<span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> java.awt.image.BufferedImage;
<span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;
<span class="hljs-keyword">import</span> java.io.File;
<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> javax.imageio.ImageIO;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> <span class="hljs-keyword">throws</span> Exception </span>{
        Socket soc;
        BufferedImage img = <span class="hljs-keyword">null</span>;
        soc = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">4000</span>);
        System.out.println(<span class="hljs-string">"Client is running."</span>);
        <span class="hljs-keyword">try</span> {
            System.out.println(<span class="hljs-string">"Reading image from disk."</span>);
            img = ImageIO.read(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"digital_image_processing.jpg"</span>));
            ByteArrayOutputStream baos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();
            ImageIO.write(img, <span class="hljs-string">"jpg"</span>, baos);
            baos.flush();
            <span class="hljs-keyword">byte</span>[] bytes = baos.toByteArray();
            baos.close();
            System.out.println(<span class="hljs-string">"Sending image to server."</span>);
            OutputStream out = soc.getOutputStream();
            DataOutputStream dos = <span class="hljs-keyword">new</span> DataOutputStream(out);
            dos.writeInt(bytes.length);
            dos.write(bytes, <span class="hljs-number">0</span>, bytes.length);
            System.out.println(<span class="hljs-string">"Image sent to server."</span>);
            dos.close();
            out.close();
        } <span class="hljs-keyword">catch</span> (Exception e) {
            System.out.println(<span class="hljs-string">"Exception: "</span> + e.getMessage());
            soc.close();
        }
        soc.close();
    }
}
</div></code></pre>
<h3 id="server">Server</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.net.*;
<span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> java.awt.image.*;
<span class="hljs-keyword">import</span> javax.imageio.*;
<span class="hljs-keyword">import</span> javax.swing.*;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> <span class="hljs-keyword">throws</span> Exception </span>{
        ServerSocket server = <span class="hljs-keyword">null</span>;
        Socket socket;
        server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">4000</span>);
        System.out.println(<span class="hljs-string">"Server waiting for image."</span>);
        socket = server.accept();
        System.out.println(<span class="hljs-string">"Client connected."</span>);
        InputStream in = socket.getInputStream();
        DataInputStream dis = <span class="hljs-keyword">new</span> DataInputStream(in);
        <span class="hljs-keyword">int</span> len = dis.readInt();
        System.out.println(<span class="hljs-string">"Image size: "</span> + len / <span class="hljs-number">1024</span> + <span class="hljs-string">"KB"</span>);
        <span class="hljs-keyword">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[len];
        dis.readFully(data);
        dis.close();
        in.close();
        InputStream ian = <span class="hljs-keyword">new</span> ByteArrayInputStream(data);
        BufferedImage bImage = ImageIO.read(ian);
        JFrame f = <span class="hljs-keyword">new</span> JFrame(<span class="hljs-string">"Server"</span>);
        ImageIcon icon = <span class="hljs-keyword">new</span> ImageIcon(bImage);
        JLabel l = <span class="hljs-keyword">new</span> JLabel();
        l.setIcon(icon);
        f.add(l);
        f.pack();
        f.setVisible(<span class="hljs-keyword">true</span>);
    }
}
</div></code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>In this experiment, we have learned how to create a socket for HTTP for web page upload and download using Java programming language. The program prompts the user to enter a frame size and creates a frame based on the user request. The client then sends the frames to the server using a socket, and the server receives the frames and displays the image in a JFrame. The program can be useful for transmitting images over a network.</p>
<div style="page-break-after: always;"></div>
<!-- EXPERIMENT 12
Write a program to implement RPC (Remote Procedure Call)
A remote procedure call is an inter-process communication technique that is used for clientserver based applications. It is also known as a subroutine call or a function call.
A client has a request message that the RPC translates and sends to the server. This request
may be a procedure or a function call to a remote server. When the server receives the request,
it sends the required response back to the client. The client is blocked while the server is
processing the call and only resumed execution after the server is finished.
The sequence of events in a remote procedure call are given as follows âˆ’
â€¢ The client stub is called by the client.
â€¢ The client stub makes a system call to send the message to the server and puts the
parameters in the message.
â€¢ The message is sent from the client to the server by the clientâ€™s operating system.
â€¢ The message is passed to the server stub by the server operating system.
â€¢ The parameters are removed from the message by the server stub.
â€¢ Then, the server procedure is called by the server stub.
HelloWorld.java
package
rpc_helloworld;
import javax.jws.WebMethod;
import javax.jws.WebService;
import javax.jws.soap.SOAPBinding;
import javax.jws.soap.SOAPBinding.Style;
@WebService
@SOAPBinding(style = Style.RPC)
public interface HelloWorld {
@WebMethod String getHelloWorld(String name);
}
HelloWorldImpl.java
package
rpc_helloworld;
import javax.jws.WebService;
@WebService(endpointInterface =
"rpc_helloworld.HelloWorld")
public class HelloWorldImpl implements HelloWorld{
@Override
public String getHelloWorld(String name) {
return name;
}
}
Publisher.java
package
rpc_helloworld;
import javax.xml.ws.Endpoint;
public class Publisher {
public static void main(String[] args) {
Endpoint.publish("http://localhost:7779/ws/hello",
new HelloWorldImpl());
}
}
rpc_helloworld.java
package
rpc_helloworld;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.xml.namespace.QName;
import javax.xml.ws.Service;
public class RPC_HelloWorld {
public static void main(String[] args) {
try {
//Refer to wsdl document
URL url = new
URL("http://localhost:7779/ws/hello?wsdl");
//Refer to wsdl document
QName qname = new
QName("http://rpc_helloworld/",
"HelloWorldImplService");
Service service = Service.create(url,
qname);
HelloWorld hello =
service.getPort(HelloWorld.class);
System.out.println(hello.getHelloWorld("Hello
World!"));
} catch (MalformedURLException ex) {
System.out.println("WSDL document url
error: " + ex);
}
}
}
After create all these files, you need to run your Publisher.Java and then go to your browser
and type the following:
http://localhost:7779/ws/hello?wsdl
Then you will get the response in XML format. After that you need to copy the text that assign
for targetNamespace.
Then paste the text in your Client side file, as the QName first parameter. Now run your
program and you will get the output.
[https://sivakumar-prasanth.medium.com/java-rpc-remote-procedure-call-99cfaca34c36]
  -->
<h1 id="experiment-12">EXPERIMENT 12</h1>
<h2 id="aim">Aim</h2>
<p>The aim of this experiment is to write a program to implement RPC (Remote Procedure Call) in Java.</p>
<h2 id="introduction">Introduction</h2>
<p>Remote Procedure Call (RPC) is an inter-process communication technique used in client-server applications. It allows a client to call a procedure or a function on a remote server as if it were a local function call. The sequence of events in an RPC involves the client making a request to the server, the server processing the request, and sending back a response to the client.</p>
<h2 id="code">Code</h2>
<h3 id="helloworldjava">HelloWorld.java</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> rpc_helloworld;

<span class="hljs-keyword">import</span> javax.jws.WebMethod;
<span class="hljs-keyword">import</span> javax.jws.WebService;
<span class="hljs-keyword">import</span> javax.jws.soap.SOAPBinding;
<span class="hljs-keyword">import</span> javax.jws.soap.SOAPBinding.Style;

<span class="hljs-meta">@WebService</span>
<span class="hljs-meta">@SOAPBinding</span>(style = Style.RPC)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HelloWorld</span> </span>{
    <span class="hljs-meta">@WebMethod</span>
    <span class="hljs-function">String <span class="hljs-title">getHelloWorld</span><span class="hljs-params">(String name)</span></span>;
}
</div></code></pre>
<h3 id="helloworldimpljava">HelloWorldImpl.java</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> rpc_helloworld;

<span class="hljs-keyword">import</span> javax.jws.WebService;

<span class="hljs-meta">@WebService</span>(endpointInterface = <span class="hljs-string">"rpc_helloworld.HelloWorld"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HelloWorld</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getHelloWorld</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">return</span> name;
    }
}
</div></code></pre>
<h3 id="publisherjava">Publisher.java</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> rpc_helloworld;

<span class="hljs-keyword">import</span> javax.xml.ws.Endpoint;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Publisher</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Endpoint.publish(<span class="hljs-string">"http://localhost:7779/ws/hello"</span>, <span class="hljs-keyword">new</span> HelloWorldImpl());
    }
}
</div></code></pre>
<h3 id="rpchelloworldjava">rpc_helloworld.java</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> rpc_helloworld;

<span class="hljs-keyword">import</span> java.net.MalformedURLException;
<span class="hljs-keyword">import</span> java.net.URL;
<span class="hljs-keyword">import</span> java.util.logging.Level;
<span class="hljs-keyword">import</span> java.util.logging.Logger;
<span class="hljs-keyword">import</span> javax.xml.namespace.QName;
<span class="hljs-keyword">import</span> javax.xml.ws.Service;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RPC_HelloWorld</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Refer to WSDL document</span>
            URL url = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">"http://localhost:7779/ws/hello?wsdl"</span>);

            <span class="hljs-comment">// Refer to service</span>
            QName qname = <span class="hljs-keyword">new</span> QName(<span class="hljs-string">"http://rpc_helloworld/"</span>, <span class="hljs-string">"HelloWorldImplService"</span>);
            Service service = Service.create(url, qname);

            HelloWorld hello = service.getPort(HelloWorld<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
            System.out.println(hello.getHelloWorld(<span class="hljs-string">"Hello World!"</span>));
        } <span class="hljs-keyword">catch</span> (MalformedURLException ex) {
            System.out.println(<span class="hljs-string">"WSDL document URL error: "</span> + ex);
        }
    }
}
</div></code></pre>
<h2 id="procedure">Procedure</h2>
<ol>
<li>Create a Java interface named <code>HelloWorld</code> with a method named <code>getHelloWorld</code>.</li>
<li>Annotate the interface with <code>@WebService</code> and <code>@SOAPBinding(style = Style.RPC)</code>.</li>
<li>Create a Java class named <code>HelloWorldImpl</code> that implements the <code>HelloWorld</code> interface.</li>
<li>Annotate the <code>HelloWorldImpl</code> class with <code>@WebService(endpointInterface = &quot;rpc_helloworld.HelloWorld&quot;)</code>.</li>
<li>Implement the <code>getHelloWorld</code> method in the <code>HelloWorldImpl</code> class.</li>
<li>Create a Java class named <code>Publisher</code> that publishes the <code>HelloWorldImpl</code> web service using <code>Endpoint.publish</code>.</li>
<li>Create a Java class named <code>RPC_HelloWorld</code> that invokes the <code>getHelloWorld</code> method using <code>Service.create</code> and <code>service.getPort</code>.</li>
<li>Run the <code>Publisher</code> class to publish the web service on <code>http://localhost:7779/ws/hello</code>.</li>
<li>Open a web browser and enter the URL <code>http://localhost:7779/ws/hello?wsdl</code> to view the web service WSDL document.</li>
<li>Copy the targetNamespace from the WSDL document and paste it into the <code>QName</code> object in the <code>RPC_HelloWorld</code> class.</li>
<li>Run the <code>RPC_HelloWorld</code> class to invoke the <code>getHelloWorld</code> method on the remote server.</li>
</ol>
<h2 id="conclusion">Conclusion</h2>
<p>In this experiment, we have learned how to implement Remote Procedure Call (RPC) in Java. We created a web service using JAX-WS and published it using <code>Endpoint.publish</code>. We then invoked the remote procedure using <code>Service.create</code> and <code>service.getPort</code>. The program can be useful for implementing client-server applications that require remote procedure calls.</p>
<div style="page-break-after: always;"></div>
<!-- EXPERIMENT 13
Implementation of Subnetting.
import java.util.Scanner;
class Subnet{
public static void main(String args[]){
Scanner sc = new Scanner(System.in);
System.out.print(â€œEnter the ip address: â€œ);
String ip = sc.nextLine();
String split_ip[] = ip.split(â€œ\\.â€); //SPlit the string after every .
String split_bip[] = new String[4]; //split binary ip
String bip = â€œâ€;
for(int i=0;i<4;i++){
split_bip[i] = appendZeros(Integer.toBinaryString(Integer.parseInt(split_ip[i]))); // â€œ18â€ => 18
=> 10010 => 00010010
bip += split_bip[i];
}
System.out.println(â€œIP in binary is â€œ+bip);
System.out.print(â€œEnter the number of addresses: â€œ);
int n = sc.nextInt();
//Calculation of mask
int bits = (int)Math.ceil(Math.log(n)/Math.log(2)); /*eg if address = 120, log 120/log 2 gives
log to the base 2 => 6.9068, ceil gives us upper integer */
System.out.println(â€œNumber of bits required for address = â€œ+bits);
int mask = 32-bits;
System.out.println(â€œThe subnet mask is = â€œ+mask);
//Calculation of first address and last address
int fbip[] = new int[32];
for(int i=0; i<32;i++) fbip[i] = (int)bip.charAt(i)-48; //convert cahracter 0,1 to integer 0,1
for(int i=31;i>31-bits;iâ€“)//Get first address by ANDing last n bits with 0
fbip[i] &= 0;
String fip[] = {â€œâ€,â€â€,â€â€,â€â€};
for(int i=0;i<32;i++)
fip[i/8] = new String(fip[i/8]+fbip[i]);
System.out.print(â€œFirst address is = â€œ);
for(int i=0;i<4;i++){
System.out.print(Integer.parseInt(fip[i],2));
if(i!=3) System.out.print(â€œ.â€);
}
System.out.println();
int lbip[] = new int[32];
for(int i=0; i<32;i++) lbip[i] = (int)bip.charAt(i)-48; //convert cahracter 0,1 to integer 0,1
for(int i=31;i>31-bits;iâ€“)//Get last address by ORing last n bits with 1
lbip[i] |= 1;
String lip[] = {â€œâ€,â€â€,â€â€,â€â€};
for(int i=0;i<32;i++)
lip[i/8] = new String(lip[i/8]+lbip[i]);
System.out.print(â€œLast address is = â€œ);
for(int i=0;i<4;i++){
System.out.print(Integer.parseInt(lip[i],2));
if(i!=3) System.out.print(â€œ.â€);
}
System.out.println();
}
static String appendZeros(String s){
String temp = new String(â€œ00000000â€);
return temp.substring(s.length())+ s;
}
}
/*Output
Enter the ip address: 100.110.150.10
IP in binary is 01100100011011101001011000001010
Enter the number of addresses: 7
Number of bits required for address = 3
The subnet mask is = 29
First address is = 100.110.150.8
Last address is = 100.110.150.15
*/
-->
<h1 id="experiment-13">EXPERIMENT 13</h1>
<h2 id="aim">Aim</h2>
<p>The aim of this experiment is to implement subnetting in Java.</p>
<h2 id="code">Code</h2>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subnet</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>{
        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);
        System.out.print(<span class="hljs-string">"Enter the IP address: "</span>);
        String ip = sc.nextLine();
        String split_ip[] = ip.split(<span class="hljs-string">"\\."</span>);
        String split_bip[] = <span class="hljs-keyword">new</span> String[<span class="hljs-number">4</span>];
        String bip = <span class="hljs-string">""</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {
            split_bip[i] = appendZeros(Integer.toBinaryString(Integer.parseInt(split_ip[i])));
            bip += split_bip[i];
        }
        System.out.println(<span class="hljs-string">"IP in binary is "</span> + bip);
        System.out.print(<span class="hljs-string">"Enter the number of addresses: "</span>);
        <span class="hljs-keyword">int</span> n = sc.nextInt();

        <span class="hljs-comment">// Calculation of mask</span>
        <span class="hljs-keyword">int</span> bits = (<span class="hljs-keyword">int</span>) Math.ceil(Math.log(n) / Math.log(<span class="hljs-number">2</span>));
        System.out.println(<span class="hljs-string">"Number of bits required for address = "</span> + bits);
        <span class="hljs-keyword">int</span> mask = <span class="hljs-number">32</span> - bits;
        System.out.println(<span class="hljs-string">"The subnet mask is = "</span> + mask);

        <span class="hljs-comment">// Calculation of first address and last address</span>
        <span class="hljs-keyword">int</span> fbip[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">32</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) {
            fbip[i] = (<span class="hljs-keyword">int</span>) bip.charAt(i) - <span class="hljs-number">48</span>; <span class="hljs-comment">// Convert character 0,1 to integer 0,1</span>
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">31</span>; i &gt; <span class="hljs-number">31</span> - bits; i--) { <span class="hljs-comment">// Get first address by ANDing last n bits with 0</span>
            fbip[i] &amp;= <span class="hljs-number">0</span>;
        }
        String fip[] = { <span class="hljs-string">""</span>, <span class="hljs-string">""</span>, <span class="hljs-string">""</span>, <span class="hljs-string">""</span> };
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) {
            fip[i / <span class="hljs-number">8</span>] = <span class="hljs-keyword">new</span> String(fip[i / <span class="hljs-number">8</span>] + fbip[i]);
        }
        System.out.print(<span class="hljs-string">"First address is = "</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {
            System.out.print(Integer.parseInt(fip[i], <span class="hljs-number">2</span>));
            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">3</span>)
                System.out.print(<span class="hljs-string">"."</span>);
        }
        System.out.println();

        <span class="hljs-keyword">int</span> lbip[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">32</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) {
            lbip[i] = (<span class="hljs-keyword">int</span>) bip.charAt(i) - <span class="hljs-number">48</span>; <span class="hljs-comment">// Convert character 0,1 to integer 0,1</span>
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">31</span>; i &gt; <span class="hljs-number">31</span> - bits; i--) { <span class="hljs-comment">// Get last address by ORing last n bits with 1</span>
            lbip[i] |= <span class="hljs-number">1</span>;
        }
        String lip[] = { <span class="hljs-string">""</span>, <span class="hljs-string">""</span>, <span class="hljs-string">""</span>, <span class="hljs-string">""</span> };
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) {
            lip[i / <span class="hljs-number">8</span>] = <span class="hljs-keyword">new</span> String(lip[i / <span class="hljs-number">8</span>] + lbip[i]);
        }
        System.out.print(<span class="hljs-string">"Last address is = "</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {
            System.out.print(Integer.parseInt(lip[i], <span class="hljs-number">2</span>));
            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">3</span>)
                System.out.print(<span class="hljs-string">"."</span>);
        }
        System.out.println();
    }

    <span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">appendZeros</span><span class="hljs-params">(String s)</span> </span>{
        String temp = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"00000000"</span>);
        <span class="hljs-keyword">return</span> temp.substring(s.length()) + s;
    }
}
</div></code></pre>
<h2 id="output">Output</h2>
<p><img src="https://i.imgur.com/RKXqfyN.png" alt="Subnet"></p>
<h2 id="conclusion">Conclusion</h2>
<p>In this experiment, we implemented subnetting in Java.</p>
<div style="page-break-after: always;"></div>
<!-- EXPERIMENT 14 A
IMPLEMENTATION OF TCP/IP ECHO.ALGORITHM
Server
1. Create a server socket and bind it to port.
2. Listen for new connection and when a connection arrives, accept it.
3. Read the data from client.
4. Echo the data back to the client.
5. Repeat steps 4-5 until â€žbyeâ€Ÿ or â€žnullâ€Ÿ is read.
6. Close all streams.
7. Close the server socket.
8. Stop.
Client
1. Create a client socket and connect it to the serverâ€Ÿs port number.
2. Get input from user.
3. If equal to bye or null, then go to step 7.
4. Send user data to the server.
5. Display the data echoed by the server.
6. Repeat steps 2-4.
7. Close the input and output streams.
8. Close the client socket.
9. Stop.
OUTPUT
Server:
$ javac tcpechoserver.java
$ java tcpechoserver
Server Ready Client Connected Client [ hello ]
Client [ how are you ] Client [ i am fine ] Client [ ok ]
Client Disconnected
Client :
$ javac tcpechoclient.java
$ java tcpechoclient
Type "bye" to quit
Enter msg to server : hello
Server [ hello ]
Enter msg to server : how are you
Server [ how are you ]
Enter msg to server : i am fine
Server [ i am fine ]
Enter msg to server : ok
Server [ ok ]
Enter msg to server : bye
/ TCP Echo Server--tcpechoserver.java
import java.net.*;
import java.io.*;
public class tcpechoserver
{
public static void main(String[] arg) throws
IOException
{
ServerSocket sock = null;
BufferedReader fromClient = null;
OutputStreamWriter toClient = null;
Socket client = null;
try
{
sock = new ServerSocket(4000);
System.out.println("Server Ready");
client = sock.accept();
System.out.println("Client Connected");
fromClient = new BufferedReader(new
InputStreamReader(client.getInputStream()));
toClient = new
OutputStreamWriter(client.getOutputStream());
String line;
while (true)
{
line = fromClient.readLine();
if ( (line == null) || line.equals("bye"))
break;
System.out.println ("Client [ " + line + " ]");
toClient.write("Server [ "+ line +" ]\n");
toClient.flush();
}
fromClient.close();
toClient.close();
client.close();
sock.close();
System.out.println("Client Disconnected");
}
catch (IOException ioe)
{
System.err.println(ioe);
}
}
}
//TCP Echo Client--tcpechoclient.java
import java.net.*;
import java.io.*;
public class tcpechoclient
{
public static void main(String[] args) throws
IOException
{
BufferedReader fromServer = null, fromUser =
null;
PrintWriter toServer = null;
Socket sock = null;
try
{
if (args.length == 0)
sock = new
Socket(InetAddress.getLocalHost(),4000);
else
sock = new
Socket(InetAddress.getByName(args[0]),4000);
fromServer = new BufferedReader(new
InputStreamReader(sock.getInputStream()));
fromUser = new BufferedReader(new
InputStreamReader(System.in));
toServer = new
PrintWriter(sock.getOutputStream(),true);
String Usrmsg, Srvmsg;
System.out.println("Type \"bye\" to quit");
while (true)
{
System.out.print("Enter msg to server : ");
Usrmsg = fromUser.readLine();
if (Usrmsg==null || Usrmsg.equals("bye"))
{
toServer.println("bye"); break;
}
else
toServer.println(Usrmsg);
Srvmsg = fromServer.readLine();
System.out.println(Srvmsg);
}
fromUser.close();
fromServer.close();
toServer.close();
sock.close();
}
catch (IOException ioe)
{
System.err.println(ioe);
}
 -->
<h1 id="experiment-14">EXPERIMENT 14</h1>
<h2 id="aim">Aim</h2>
<p>The aim of this experiment is to implement TCP/IP echo algorithm using Java sockets.</p>
<h2 id="server">Server</h2>
<ol>
<li>Create a server socket and bind it to a port.</li>
<li>Listen for new connections and when a connection arrives, accept it.</li>
<li>Read the data from the client.</li>
<li>Echo the data back to the client.</li>
<li>Repeat steps 4-5 until &quot;bye&quot; or &quot;null&quot; is read.</li>
<li>Close all streams.</li>
<li>Close the server socket.</li>
<li>Stop.</li>
</ol>
<h2 id="client">Client</h2>
<ol>
<li>Create a client socket and connect it to the server's port number.</li>
<li>Get input from the user.</li>
<li>If equal to &quot;bye&quot; or &quot;null&quot;, then go to step 7.</li>
<li>Send user data to the server.</li>
<li>Display the data echoed by the server.</li>
<li>Repeat steps 2-4.</li>
<li>Close the input and output streams.</li>
<li>Close the client socket.</li>
<li>Stop.</li>
</ol>
<h2 id="code">Code</h2>
<h3 id="tcp-echo-server---tcpechoserverjava">TCP Echo Server - tcpechoserver.java</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.net.*;
<span class="hljs-keyword">import</span> java.io.*;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">tcpechoserver</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] arg)</span> <span class="hljs-keyword">throws</span> IOException </span>{
        ServerSocket sock = <span class="hljs-keyword">null</span>;
        BufferedReader fromClient = <span class="hljs-keyword">null</span>;
        OutputStreamWriter toClient = <span class="hljs-keyword">null</span>;
        Socket client = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> {
            sock = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">4000</span>);
            System.out.println(<span class="hljs-string">"Server Ready"</span>);
            client = sock.accept();
            System.out.println(<span class="hljs-string">"Client Connected"</span>);
            fromClient = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(client.getInputStream()));
            toClient = <span class="hljs-keyword">new</span> OutputStreamWriter(client.getOutputStream());
            String line;
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
                line = fromClient.readLine();
                <span class="hljs-keyword">if</span> ((line == <span class="hljs-keyword">null</span>) || line.equals(<span class="hljs-string">"bye"</span>))
                    <span class="hljs-keyword">break</span>;
                System.out.println(<span class="hljs-string">"Client [ "</span> + line + <span class="hljs-string">" ]"</span>);
                toClient.write(<span class="hljs-string">"Server [ "</span> + line + <span class="hljs-string">" ]\n"</span>);
                toClient.flush();
            }
            fromClient.close();
            toClient.close();
            client.close();
            sock.close();
            System.out.println(<span class="hljs-string">"Client Disconnected"</span>);
        } <span class="hljs-keyword">catch</span> (IOException ioe) {
            System.err.println(ioe);
        }
    }
}
</div></code></pre>
<h3 id="tcp-echo-client---tcpechoclientjava">TCP Echo Client - tcpechoclient.java</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.net.*;
<span class="hljs-keyword">import</span> java.io.*;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">tcpechoclient</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>{
        BufferedReader fromServer = <span class="hljs-keyword">null</span>, fromUser = <span class="hljs-keyword">null</span>;
        PrintWriter toServer = <span class="hljs-keyword">null</span>;
        Socket sock = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">if</span> (args.length == <span class="hljs-number">0</span>)
                sock = <span class="hljs-keyword">new</span> Socket(InetAddress.getLocalHost(), <span class="hljs-number">4000</span>);
            <span class="hljs-keyword">else</span>
                sock = <span class="hljs-keyword">new</span> Socket(InetAddress.getByName(args[<span class="hljs-number">0</span>]), <span class="hljs-number">4000</span>);
            fromServer = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(sock.getInputStream()));
            fromUser = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));
            toServer = <span class="hljs-keyword">new</span> PrintWriter(sock.getOutputStream(), <span class="hljs-keyword">true</span>);
            String Usrmsg, Srvmsg;
            System.out.println(<span class="hljs-string">"Type \"bye\" to quit"</span>);
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
                System.out.print(<span class="hljs-string">"Enter msg to server : "</span>);
                Usrmsg = fromUser.readLine();
                <span class="hljs-keyword">if</span> (Usrmsg == <span class="hljs-keyword">null</span> || Usrmsg.equals(<span class="hljs-string">"bye"</span>)) {
                    toServer.println(<span class="hljs-string">"bye"</span>);
                    <span class="hljs-keyword">break</span>;
                } <span class="hljs-keyword">else</span>
                    toServer.println(Usrmsg);
                Srvmsg = fromServer.readLine();
                System.out.println(Srvmsg);
            }
            fromUser.close();
            fromServer.close();
            toServer.close();
            sock.close();
        } <span class="hljs-keyword">catch</span> (IOException ioe) {
            System.err.println(ioe);
        }
    }
}
</div></code></pre>
<h2 id="output">Output</h2>
<h3 id="server">Server</h3>
<pre class="hljs"><code><div>$ javac tcpechoserver.java
$ java tcpechoserver
Server Ready
Client Connected
Client [ hello ]
Client [ how are you ]
Client [ i am fine ]
Client [ ok ]
Client Disconnected
</div></code></pre>
<h3 id="client">Client</h3>
<pre class="hljs"><code><div>$ javac tcpechoclient.java
$ java tcpechoclient
Type &quot;bye&quot; to quit
Enter msg to server : hello
Server [ hello ]
Enter msg to server : how are you
Server [ how are you ]
Enter msg to server : i am fine
Server [ i am fine ]
Enter msg to server : ok
Server [ ok ]
Enter msg to server : bye
</div></code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>The TCP/IP echo algorithm was successfully implemented using Java sockets. The server listens for incoming connections and echoes back whatever data it receives from the client until the client sends the &quot;bye&quot; or &quot;null&quot; message. The client sends data to the server and displays the echoed data until the user types &quot;bye&quot; or &quot;null&quot;.</p>
<div style="page-break-after: always;"></div>
<!-- XPERIMENT 15
Program to implement DNS in java
import java.net.*;
import java.io.*;
import java.util.*;
public class DNS
{
public static void main(String[] args)
{
int n;
BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
do
{
System.out.println("\n Menu: \n 1. DNS 2. Reverse DNS 3. Exit \n");
System.out.println("\n Enter your choice");
n = Integer.parseInt(System.console().readLine());
if(n==1)
{
try
{
System.out.println("\n Enter Host Name ");
String hname=in.readLine();
InetAddress address;
address = InetAddress.getByName(hname);
System.out.println("Host Name: " + address.getHostName());
System.out.println("IP: " + address.getHostAddress());
}
catch(IOException ioe)
{
ioe.printStackTrace();
}
}
if(n==2)
{
try
{
System.out.println("\n Enter IP address");
String ipstr = in.readLine();
InetAddress ia = InetAddress.getByName(ipstr);
System.out.println("IP: "+ipstr);
System.out.println("Host Name: " +ia.getHostName());
}
catch(IOException ioe)
{
ioe.printStackTrace();
}
}
}while(!(n==3));
}
} -->
<h1 id="experiment-15">EXPERIMENT 15</h1>
<h2 id="aim">Aim</h2>
<p>The aim of this experiment is to implement DNS (Domain Name System) in Java.</p>
<h2 id="code">Code</h2>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.net.*;
<span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> java.util.*;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DNS</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span> n;
        BufferedReader in = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));
        <span class="hljs-keyword">do</span> {
            System.out.println(<span class="hljs-string">"\n Menu: \n 1. DNS\n 2. Reverse DNS\n 3. Exit \n"</span>);
            System.out.println(<span class="hljs-string">"\n Enter your choice"</span>);
            n = Integer.parseInt(System.console().readLine());
            <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) {
                <span class="hljs-keyword">try</span> {
                    System.out.println(<span class="hljs-string">"\n Enter Host Name "</span>);
                    String hname = in.readLine();
                    InetAddress address;
                    address = InetAddress.getByName(hname);
                    System.out.println(<span class="hljs-string">"Host Name: "</span> + address.getHostName());
                    System.out.println(<span class="hljs-string">"IP: "</span> + address.getHostAddress());
                } <span class="hljs-keyword">catch</span> (IOException ioe) {
                    ioe.printStackTrace();
                }
            }
            <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) {
                <span class="hljs-keyword">try</span> {
                    System.out.println(<span class="hljs-string">"\n Enter IP address"</span>);
                    String ipstr = in.readLine();
                    InetAddress ia = InetAddress.getByName(ipstr);
                    System.out.println(<span class="hljs-string">"IP: "</span> + ipstr);
                    System.out.println(<span class="hljs-string">"Host Name: "</span> + ia.getHostName());
                } <span class="hljs-keyword">catch</span> (IOException ioe) {
                    ioe.printStackTrace();
                }
            }
        } <span class="hljs-keyword">while</span> (!(n == <span class="hljs-number">3</span>));
    }
}
</div></code></pre>
<h2 id="explanation">Explanation</h2>
<p>The program starts by taking input from the user in the form of a menu. The user is given the option to choose between DNS, reverse DNS, or to exit the program. If the user selects the DNS option, the program prompts the user to enter a host name. The program then uses the <code>getByName()</code> method of the <code>InetAddress</code> class to obtain an IP address object for the specified host name. The program outputs the host name and IP address of the specified host name. If the user selects the reverse DNS option, the program prompts the user to enter an IP address. The program then uses the <code>getByName()</code> method of the <code>InetAddress</code> class to obtain a host name object for the specified IP address. The program outputs the IP address and host name of the specified IP address. The program continues to loop until the user selects the exit option.</p>
<h2 id="output">Output</h2>
<p><img src="https://i.imgur.com/8gJXdd6.png" alt="DNS"></p>
<h2 id="conclusion">Conclusion</h2>
<p>The program successfully implements DNS (Domain Name System) in Java. It allows the user to enter a host name and displays the corresponding IP address, as well as the ability to enter an IP address and display the corresponding host name.</p>

</body>
</html>
