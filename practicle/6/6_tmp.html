<!DOCTYPE html>
<html>
<head>
<title>6.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<!--
EXPERIMENT 6
Simulation of Distance Vector/Link State Routing.
a) Distance Vector routing protocol ROUTING
Aim:
To simulate and study the link state routing algorithm using simulation using NS2.
Routing is the process of selecting best paths in a network. In the past, the term
routing was also used to mean forwarding network traffic among networks. However this
latter function is muchbetter described as simply forwarding. Routing is performed for
many kinds of networks, including the telephone network (circuit switching), electronic
data networks (such as the Internet), and transportation networks. This article is concerned
primarily with routing in electronic data networks using packet switching technology
.In packet switching networks, routing directs packet forwarding (the transit of logically
addressed network packets from their source toward their ultimate destination) through
intermediate nodes. Intermediate nodes are typically network hardware devices such as
routers, bridges, gateways, firewalls, or switches. General-purpose computers can also
forward packets and perform routing, though they are not specialized hardware and may
suffer from limited performance. The routing process usually directs forwarding on the
basis of routing tables which maintain a record of the routes to various network destinations.
Thus, constructing routing tables, which are held in the router's memory, is very important
for efficient routing. Most routing algorithms use only one network path at a time.
Multipath routing techniques enable the use of multiple alternative paths. In case of
overlapping/equal routes, the following elements are considered in order to decide
which routes get installed into the routing table (sorted by priority):
1. Prefix-Length: where longer subnet masks are preferred (independent of whether it is
within a routing
protocol or over different routing protocol)
2. Metric: where a lower metric/cost is preferred (only valid within one and the same
routing protocol)
3. Administrative distance: where a lower distance is preferred (only valid between
different routing protocols) Routing, in a more narrow sense of the term, is often
contrasted with bridging in its assumption that network addresses are structured and that
similar addresses imply proximity within the network. Structured addresses allow a single
routing table entry to represent the route to a group of devices. In large networks,
Distance Vector routing protocol
structured addressing (routing, in the narrow sense) outperforms unstructured
addressing (bridging). Routing has become the dominant form of addressing on the
Internet. Bridging is still widely used within localized environments.
Algorithm
There are several variants of flooding algorithm. Most work roughly
as follows:
1. Each node acts as both a transmitter and a receiver.
2. Each node tries to forward every message to every one of its neighbours except the
source node. This results in every message eventually being delivered to all reachable
parts of the network. Algorithms may need to be more complex than this, since, in
some case, precautions have to be taken to avoid wasted duplicate deliveries and
infinite loops, and to allow messages to eventually expire from the system. A variant
of flooding called selective flooding partially addresses these issues by only sending
packets to routers in the same direction. In selective flooding the routers don't send
every incoming packet on every line but only on those lines which are going
approximately in the right direction.
Program:
set ns [new Simulator]
set nf [open out.nam w]
$ns namtrace-all $nf
set tr [open out.tr w]
$ns trace-all $tr
proc finish {} {
global nf ns tr
$ns flush-trace
close $tr
exec nam out.nam &
exit 0
}
set n0 [$ns node]
set n1 [$ns node]
set n2 [$ns node]
set n3 [$ns node]
$ns duplex-link $n0 $n1 10Mb 10ms DropTail
$ns duplex-link $n1 $n3 10Mb 10ms DropTail
$ns duplex-link $n2 $n1 10Mb 10ms DropTail
$ns duplex-link-op $n0 $n1 orient right-down
$ns duplex-link-op $n1 $n3 orient right
$ns duplex-link-op $n2 $n1 orient right-up
set tcp [new Agent/TCP]
$ns attach-agent $n0 $tcp
set ftp [new Application/FTP]
$ftp attach-agent $tcp
set sink [new Agent/TCPSink]
$ns attach-agent $n3 $sink
set udp [new Agent/UDP]
$ns attach-agent $n2 $udp
set cbr [new Application/Traffic/CBR]
$cbr attach-agent $udp
set null [new Agent/Null]
$ns attach-agent $n3 $null
$ns connect $tcp $sink
$ns connect $udp $null
$ns rtmodel-at 1.0 down $n1 $n3
$ns rtmodel-at 2.0 up $n1 $n3
$ns rtproto DV
$ns at 0.0 "$ftp start"
$ns at 0.0 "$cbr start"
$ns at 5.0 "finish"
$ns run
Result:
Thus the Distance Vector Routing Algorithm was Simulated and studied -->
<h1 id="experiment-6a">Experiment 6A</h1>
<h2 id="aim">Aim</h2>
<p>To simulate and study the Distance Vector routing algorithm using simulation using NS2.</p>
<h2 id="theory">Theory</h2>
<h3 id="introduction">Introduction</h3>
<p>Routing is the process of selecting the best paths in a network. In electronic data networks using packet switching technology, routing directs packet forwarding through intermediate nodes. Intermediate nodes are typically network hardware devices such as routers, bridges, gateways, firewalls, or switches. The routing process usually directs forwarding on the basis of routing tables which maintain a record of the routes to various network destinations. Most routing algorithms use only one network path at a time. However, multipath routing techniques enable the use of multiple alternative paths.</p>
<h3 id="algorithm">Algorithm</h3>
<p>The Distance Vector routing protocol works as follows:</p>
<ol>
<li>Each router maintains a table that lists the cost of reaching each destination network in the internetwork.</li>
<li>Each router periodically shares its routing table with its neighboring routers.</li>
<li>Each router updates its own routing table based on the information it receives from its neighbors.</li>
<li>The router selects the path with the lowest cost to the destination network as the best path.</li>
<li>The router forwards packets to the next hop router in the best path.</li>
</ol>
<h3 id="program">Program</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">set</span> ns [new Simulator]
<span class="hljs-keyword">set</span> nf [<span class="hljs-keyword">open</span> out.nam w]
$ns namtrace-all $nf
<span class="hljs-keyword">set</span> tr [<span class="hljs-keyword">open</span> out.tr w]
$ns <span class="hljs-keyword">trace</span>-all $tr

<span class="hljs-keyword">proc</span><span class="hljs-title"> finish</span> {} {
    <span class="hljs-keyword">global</span> nf ns tr
    $ns <span class="hljs-keyword">flush</span>-<span class="hljs-keyword">trace</span>
    <span class="hljs-keyword">close</span> $tr
    <span class="hljs-keyword">exec</span> nam out.nam &amp;
    <span class="hljs-keyword">exit</span> <span class="hljs-number">0</span>
}

<span class="hljs-keyword">set</span> n0 [$ns node]
<span class="hljs-keyword">set</span> n1 [$ns node]
<span class="hljs-keyword">set</span> n2 [$ns node]
<span class="hljs-keyword">set</span> n3 [$ns node]

$ns duplex-link $n0 $n1 <span class="hljs-number">10</span>Mb <span class="hljs-number">10</span>ms DropTail
$ns duplex-link $n1 $n3 <span class="hljs-number">10</span>Mb <span class="hljs-number">10</span>ms DropTail
$ns duplex-link $n2 $n1 <span class="hljs-number">10</span>Mb <span class="hljs-number">10</span>ms DropTail

$ns duplex-link-op $n0 $n1 orient right-down
$ns duplex-link-op $n1 $n3 orient right
$ns duplex-link-op $n2 $n1 orient right-up

<span class="hljs-keyword">set</span> tcp [new Agent/TCP]
$ns attach-agent $n0 $tcp

<span class="hljs-keyword">set</span> ftp [new Application/FTP]
$ftp attach-agent $tcp

<span class="hljs-keyword">set</span> sink [new Agent/TCPSink]
$ns attach-agent $n3 $sink

<span class="hljs-keyword">set</span> udp [new Agent/UDP]
$ns attach-agent $n2 $udp

<span class="hljs-keyword">set</span> cbr [new Application/Traffic/CBR]
$cbr attach-agent $udp

<span class="hljs-keyword">set</span> null [new Agent/Null]
$ns attach-agent $n3 $null

$ns connect $tcp $sink
$ns connect $udp $null

$ns rtmodel-at <span class="hljs-number">1.0</span> down $n1 $n3
$ns rtmodel-at <span class="hljs-number">2.0</span> up $n1 $n3

$ns rtproto DV

$ns at <span class="hljs-number">0.0</span> <span class="hljs-string">"$ftp start"</span>
$ns at <span class="hljs-number">0.0</span> <span class="hljs-string">"$cbr start"</span>
$ns at <span class="hljs-number">5.0</span> <span class="hljs-string">"finish"</span>

$ns run
</div></code></pre>
<h2 id="result">Result</h2>
<p>The Distance Vector Routing Algorithm was successfully simulated and studied using NS2.</p>
<div style="page-break-after: always;"></div>
<h1 id="experiment-6b-simulation-of-link-state-routing-algorithm">Experiment 6B: Simulation of Link State Routing Algorithm</h1>
<h2 id="aim">Aim</h2>
<p>To simulate and study the Link State Routing algorithm using NS2.</p>
<h2 id="link-state-routing-protocol">Link State Routing Protocol</h2>
<p>In Link State Routing, each router shares its knowledge of its neighborhood with every other
router in the internetwork. The protocol works as follows:</p>
<ol>
<li>Knowledge about Neighborhood: Instead of sending its entire routing table, a router sends information about its neighborhood only.</li>
<li>To all Routers: Each router sends this information to every other router on the internet work, not just to its neighbor. It does so by a process called flooding.</li>
<li>Information sharing when there is a change: Each router sends out information about the neighbors when there is a change.</li>
</ol>
<h2 id="algorithm">Algorithm</h2>
<p>The following algorithm is used to simulate the Link State Routing protocol:</p>
<ol>
<li>Create a simulator object.</li>
<li>Define different colors for different data flows.</li>
<li>Open a nam trace file and define a finish procedure. Then close the trace file and execute nam on trace file.</li>
<li>Create n number of nodes using a for loop.</li>
<li>Create duplex links between the nodes.</li>
<li>Setup UDP Connection between n(0) and n(5).</li>
<li>Setup another UDP connection between n(1) and n(5).</li>
<li>Apply CBR Traffic over both UDP connections.</li>
<li>Choose Link State Routing protocol to transmit data from sender to receiver.</li>
<li>Schedule events and run the program.</li>
</ol>
<h2 id="program">Program</h2>
<pre class="hljs"><code><div><span class="hljs-keyword">set</span> ns [new Simulator]
<span class="hljs-keyword">set</span> nf [<span class="hljs-keyword">open</span> out.nam w]
$ns namtrace-all $nf
<span class="hljs-keyword">set</span> tr [<span class="hljs-keyword">open</span> out.tr w]
$ns <span class="hljs-keyword">trace</span>-all $tr

<span class="hljs-keyword">proc</span><span class="hljs-title"> finish</span> {} {
    <span class="hljs-keyword">global</span> nf ns tr
    $ns <span class="hljs-keyword">flush</span>-<span class="hljs-keyword">trace</span>
    <span class="hljs-keyword">close</span> $tr
    <span class="hljs-keyword">exec</span> nam out.nam &amp;
    <span class="hljs-keyword">exit</span> <span class="hljs-number">0</span>
}

<span class="hljs-keyword">set</span> n0 [$ns node]
<span class="hljs-keyword">set</span> n1 [$ns node]
<span class="hljs-keyword">set</span> n2 [$ns node]
<span class="hljs-keyword">set</span> n3 [$ns node]

$ns duplex-link $n0 $n1 <span class="hljs-number">10</span>Mb <span class="hljs-number">10</span>ms DropTail
$ns duplex-link $n1 $n3 <span class="hljs-number">10</span>Mb <span class="hljs-number">10</span>ms DropTail
$ns duplex-link $n2 $n1 <span class="hljs-number">10</span>Mb <span class="hljs-number">10</span>ms DropTail

$ns duplex-link-op $n0 $n1 orient right-down
$ns duplex-link-op $n1 $n3 orient right
$ns duplex-link-op $n2 $n1 orient right-up

<span class="hljs-keyword">set</span> tcp [new Agent/TCP]
$ns attach-agent $n0 $tcp

<span class="hljs-keyword">set</span> ftp [new Application/FTP]
$ftp attach-agent $tcp

<span class="hljs-keyword">set</span> sink [new Agent/TCPSink]
$ns attach-agent $n3 $sink

<span class="hljs-keyword">set</span> udp [new Agent/UDP]
$ns attach-agent $n2 $udp

<span class="hljs-keyword">set</span> cbr [new Application/Traffic/CBR]
$cbr attach-agent $udp

<span class="hljs-keyword">set</span> null [new Agent/Null]
$ns attach-agent $n3 $null

$ns connect $tcp $sink
$ns connect $udp $null

$ns rtmodel-at <span class="hljs-number">1.0</span> down $n1 $n3
$ns rtmodel-at <span class="hljs-number">2.0</span> up $n1 $n3

$ns rtproto LS

$ns at <span class="hljs-number">0.0</span> <span class="hljs-string">"$ftp start"</span>
$ns at <span class="hljs-number">0.0</span> <span class="hljs-string">"$cbr start"</span>
$ns at <span class="hljs-number">5.0</span> <span class="hljs-string">"finish"</span>

$ns run
</div></code></pre>
<h2 id="result">Result</h2>
<p>The Link State Routing Algorithm was successfully simulated and studied using NS2.</p>
<div style="page-break-after: always;"></div>
<h1 id="experiment-7">Experiment 7</h1>
<h2 id="aim">Aim</h2>
<p>To implement Stop and Wait Protocol and Sliding Window Protocol.</p>
<h2 id="stop-and-wait-protocol">Stop and Wait Protocol</h2>
<p>Stop and Wait Protocol is a flow control protocol in which a sender sends one packet of data to the receiver and then waits for an acknowledgment from the receiver.</p>
<h3 id="code">Code</h3>
<h4 id="sender">Sender</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> java.net.*;
<span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StopWaitSender</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> <span class="hljs-keyword">throws</span> Exception </span>{
        StopWaitSender sws = <span class="hljs-keyword">new</span> StopWaitSender();
        sws.run();
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);
        System.out.println(<span class="hljs-string">"Enter no of frames to be sent:"</span>);
        <span class="hljs-keyword">int</span> n = sc.nextInt();
        Socket myskt = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">9999</span>);
        PrintStream myps = <span class="hljs-keyword">new</span> PrintStream(myskt.getOutputStream());

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n;) {
            <span class="hljs-keyword">if</span> (i == n) {
                myps.println(<span class="hljs-string">"exit"</span>);
                <span class="hljs-keyword">break</span>;
            }

            System.out.println(<span class="hljs-string">"Frame no "</span> + i + <span class="hljs-string">" is sent"</span>);
            myps.println(i);
            BufferedReader bf = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(myskt.getInputStream()));
            String ack = bf.readLine();

            <span class="hljs-keyword">if</span> (ack != <span class="hljs-keyword">null</span>) {
                System.out.println(<span class="hljs-string">"Acknowledgement was Received from receiver"</span>);
                i++;
                Thread.sleep(<span class="hljs-number">4000</span>);
            } <span class="hljs-keyword">else</span> {
                myps.println(i);
            }
        }
    }
}
</div></code></pre>
<h4 id="receiver">Receiver</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> java.net.*;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StopWaitReceiver</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> <span class="hljs-keyword">throws</span> Exception </span>{
        StopWaitReceiver swr = <span class="hljs-keyword">new</span> StopWaitReceiver();
        swr.run();
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
        String temp = <span class="hljs-string">"any message"</span>;
        String str = <span class="hljs-string">"exit"</span>;
        ServerSocket myss = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">9999</span>);
        Socket ss_accept = myss.accept();
        BufferedReader ss_bf = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(ss_accept.getInputStream()));
        PrintStream myps = <span class="hljs-keyword">new</span> PrintStream(ss_accept.getOutputStream());

        <span class="hljs-keyword">while</span> (temp.compareTo(str) != <span class="hljs-number">0</span>) {
            Thread.sleep(<span class="hljs-number">1000</span>);
            temp = ss_bf.readLine();

            <span class="hljs-keyword">if</span> (temp.compareTo(str) == <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">break</span>;
            }

            System.out.println(<span class="hljs-string">"Frame "</span> + temp + <span class="hljs-string">" was received"</span>);
            Thread.sleep(<span class="hljs-number">500</span>);
            myps.println(<span class="hljs-string">"Received"</span>);
        }

        System.out.println(<span class="hljs-string">"ALL FRAMES WERE RECEIVED SUCCESSFULLY"</span>);
    }
}
</div></code></pre>
<h3 id="output">Output</h3>
<h4 id="sender">Sender</h4>
<pre class="hljs"><code><div>Enter no of frames to be sent:
4
Frame no 0 is sent
Acknowledgement was Received from receiver
Frame no 1 is sent
Acknowledgement was Received from receiver
Frame no 2 is sent
Acknowledgement was Received from receiver
Frame no 3 is sent
Acknowledgement was Received from receiver
</div></code></pre>
<h4 id="receiver">Receiver</h4>
<pre class="hljs"><code><div>Frame 0 was received
Frame 1 was received
Frame 2 was received
Frame 3 was received
ALL FRAMES WERE RECEIVED SUCCESSFULLY
</div></code></pre>
<h2 id="sliding-window-protocol">Sliding Window Protocol</h2>
<p>Sliding Window Protocol is a flow control protocol in which a sender sends multiple packets to the receiver before receiving the acknowledgment of the first few packets.</p>
<h3 id="code">Code</h3>
<h4 id="bit-client">Bit Client</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.net.*;
<span class="hljs-keyword">import</span> java.io.*;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BitClient</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">try</span> {
            BufferedInputStream in;
            ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">500</span>);
            System.out.println(<span class="hljs-string">"Waiting for connection"</span>);
            Socket client = serverSocket.accept();
            System.out.println(<span class="hljs-string">"Received request for sending frames"</span>);
            in = <span class="hljs-keyword">new</span> BufferedInputStream(client.getInputStream());
            DataOutputStream out = <span class="hljs-keyword">new</span> DataOutputStream(client.getOutputStream());
            <span class="hljs-keyword">int</span> p = in.read();
            System.out.println(<span class="hljs-string">"Sending .... "</span>);

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= p; ++i) {
                System.out.println(<span class="hljs-string">"Sending frame no "</span> + i);
                out.write(i);
                out.flush();
                System.out.println(<span class="hljs-string">"Waiting for acknowledge"</span>);
                Thread.sleep(<span class="hljs-number">5000</span>);
                <span class="hljs-keyword">int</span> a = in.read();
                System.out.println(<span class="hljs-string">"Received acknowledge for frame no: "</span> + i + <span class="hljs-string">" as "</span> + a);
            }

            out.flush();
            in.close();
            out.close();
            client.close();
            serverSocket.close();
            System.out.println(<span class="hljs-string">"Quiting"</span>);
        } <span class="hljs-keyword">catch</span> (IOException e) {
            System.out.println(e);
        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
        }
    }
}
</div></code></pre>
<h4 id="bit-server">Bit Server</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.lang.System;
<span class="hljs-keyword">import</span> java.net.*;
<span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> java.math.*;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BitServer</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String a[])</span> </span>{
        <span class="hljs-keyword">try</span> {
            InetAddress addr = InetAddress.getByName(<span class="hljs-string">"localhost"</span>);
            System.out.println(addr);
            Socket connection = <span class="hljs-keyword">new</span> Socket(addr, <span class="hljs-number">500</span>);
            DataOutputStream out = <span class="hljs-keyword">new</span> DataOutputStream(connection.getOutputStream());
            BufferedInputStream in = <span class="hljs-keyword">new</span> BufferedInputStream(connection.getInputStream());
            BufferedInputStream inn = <span class="hljs-keyword">new</span> BufferedInputStream(connection.getInputStream());
            BufferedReader ki = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));
            <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;
            System.out.println(<span class="hljs-string">"Connect"</span>);
            System.out.println(<span class="hljs-string">"Enter the no of frames to be requested to server:"</span>);
            <span class="hljs-keyword">int</span> c = Integer.parseInt(ki.readLine());
            out.write(c);
            out.flush();
            <span class="hljs-keyword">int</span> i, jj = <span class="hljs-number">0</span>;

            <span class="hljs-keyword">while</span> (jj &lt; c) {
                i = in.read();
                System.out.println(<span class="hljs-string">"Received frame no "</span> + i);
                System.out.println(<span class="hljs-string">"Sending acknowledgement for frame no "</span> + i);
                out.write(i);
                out.flush();
                jj++;
            }

            out.flush();
            in.close();
            inn.close();
            out.close();

            System.out.println(<span class="hljs-string">"Output:"</span>);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }
    }
}
</div></code></pre>
<h3 id="output">Output</h3>
<h4 id="bit-client">Bit Client</h4>
<pre class="hljs"><code><div>Waiting for connection
Received request for sending frames
Sending ....
Sending frame no 1
Waiting for acknowledge
Received acknowledge for frame no: 1 as 1
Sending frame no 2
Waiting for acknowledge
Received acknowledge for frame no: 2 as 2
Sending frame no 3
Waiting for acknowledge
Received acknowledge for frame no: 3 as 3
Sending frame no 4
Waiting for acknowledge
Received acknowledge for frame no: 4 as 4
Quiting
</div></code></pre>
<h4 id="bit-server">Bit Server</h4>
<pre class="hljs"><code><div>localhost/127.0.0.1
Connect
Enter the no of frames to be requested to server:
4
Received frame no 1
Sending acknowledgement for frame no 1
Received frame no 2
Sending acknowledgement for frame no 2
Received frame no 3
Sending acknowledgement for frame no 3
Received frame no 4
Sending acknowledgement for frame no 4
Output:
</div></code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>Thus, we have studied the various types of flow control protocols and implemented them using Java.</p>
<div style="page-break-after: always;"></div>
<!-- EXPERIMENT 8
Study of Socket Programming and Client – Server model
Java Socket programming is used for communication between the applications running on
different JRE. Java Socket programming can be connection-oriented or connection-less. The
client in socket programming must know two information: IP Address of Server, and Port
number.
Here, we are going to make one-way client and server communication. In this application,
client sends a message to the server, server reads the message and prints it. Here, two classes
are being used: Socket and ServerSocket. The Socket class is used to communicate client and
server. Through this class, we can read and write message. The ServerSocket class is used at
server-side. The accept() method of ServerSocket class blocks the console until the client is
connected. After the successful connection of client, it returns the instance of Socket at serverside.
Socket class
A socket is simply an endpoint for communications between the machines. The Socket class
can be used to create a socket.
Important methods
Method Description
1) public InputStream getInputStream() returns the InputStream attached with this socket.
2)public OutputStream getOutputStream() returns the OutputStream attached with this socket.
3) public synchronized void close() closes this socket
ServerSocket class
The ServerSocket class can be used to create a server socket. This object is used to establish
communication with the clients.
Important methods
Method Description
1) public Socket accept() returns the socket and establish a connection between server and
client.
2) public
close()
synchronized void closes the server socket.
Example of Java Socket Programming
Creating Server:
To create the server application, we need to create the instance of ServerSocket class. Here,
we are using 6666 port number for the communication between the client and server. You
may also choose any other port number. The accept() method waits for the client. If clients
connects with the given port number, it returns an instance of Socket.
1. ServerSocket ss=new ServerSocket(6666);
2. Socket s=ss.accept();//establishes connection and waits for the client
Creating Client:
To create the client application, we need to create the instance of Socket class. Here, we need
to pass the IP address or hostname of the Server and a port number. Here, we are using
"localhost" because our server is running on same system.
1. Socket s=new Socket("localhost",6666);
Let's see a simple of Java socket programming where client sends a text and server receives
and prints it.
File: MyServer.java
import java.io.*;
import java.net.*;
File: MyClient.java
import java.io.*;
import java.net.*;
public class MyServer {
public static void main(String[] args){
try{
ServerSocket ss=new ServerSocket(6666);
Socket s=ss.accept();//establishes connection
public class MyClient {
public static void main(String[] args) {
try{
Socket s=new Socket("localhost",6666);
DataInputStream dis=new
DataInputStream(s.getInputStream());
DataOutputStream dout=new
DataOutputStream(s.getOutputStream());
String str=(String)dis.readUTF();
System.out.println("message= "+str);
dout.writeUTF("Hello Server");
dout.flush();
ss.close();
dout.close();
s.close();
}catch(Exception e){System.out.println(e);}
}
}
}catch(Exception e){System.out.println(e);}
}
}
 -->
<h1 id="experiment-8">Experiment 8</h1>
<h2 id="aim">Aim</h2>

</body>
</html>
